<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>jdk17 新特性</title>
      <link href="/vm-jdk17/"/>
      <url>/vm-jdk17/</url>
      
        <content type="html"><![CDATA[<font color=#AF3232>关注版本更新，享受技术红利</font><p>参考文档：</p><p><a href="https://www.oracle.com/news/announcement/oracle-releases-java-17-2021-09-14/" target="_blank" rel="noopener">jdk17新特性，oracle文档</a></p><p><a href="https://openjdk.org/jeps/403" target="_blank" rel="noopener">jdk17官方文档</a></p><p><a href="https://www.oracle.com/downloads/licenses/no-fee-license.html" target="_blank" rel="noopener">jdk17商用协议</a></p><blockquote><p>是否说在jdk更新的版本中，不知道有什么新特性可以提高我们的开发效率，或者说新特性可以完成什么新需求？</p></blockquote><p>为了更好利用到版本更新的红利，本文为简单化了解一下，jdk17相对于8有什么新特性。</p><h3 id="1-JDK17相关特性"><a href="#1-JDK17相关特性" class="headerlink" title="1.JDK17相关特性"></a>1.JDK17相关特性</h3><h4 id="stream-优化"><a href="#stream-优化" class="headerlink" title="stream 优化"></a>stream 优化</h4><p>总所周知，在jdk1.8中引入Stream-Api的流。</p><h4 id="1-switch-增强"><a href="#1-switch-增强" class="headerlink" title="1.switch 增强"></a>1.switch 增强</h4><p>switch的模式匹配优化。 switch是仅支持同一种数据类型的判断。<br>在多个jdk版本的优化后在jdk17迎来最终的优化，原本需要进行null的判断，且switch不支持类型的判断。</p><blockquote><p>JDK17语法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SwitchDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object o;</span><br><span class="line">        <span class="keyword">switch</span> (o) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="keyword">null</span>      -&gt; System.out.println(<span class="string">"判断是否为null"</span>);</span><br><span class="line">            <span class="keyword">case</span> String s  -&gt; System.out.println(<span class="string">"判断是否为字符串，s:"</span> + s);</span><br><span class="line">            <span class="keyword">case</span> record p  -&gt; System.out.println(<span class="string">"判断是否为Record类型: "</span> + p.toString());</span><br><span class="line">            <span class="keyword">case</span> <span class="keyword">int</span>[] arr -&gt; System.out.println(<span class="string">"判断是否为数组，长度"</span> + ia.length);</span><br><span class="line">            <span class="keyword">case</span> Integer i -&gt; System.out.println(<span class="string">"判断是否为Intger,i:"</span> + i);</span><br><span class="line">            <span class="keyword">case</span> Student s   -&gt; System.out.println(<span class="string">"判断是否为自定义对象，student:"</span> + s.toString());</span><br><span class="line">            <span class="keyword">default</span>   -&gt; System.out.println(<span class="string">"Something else"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>switch的增强历程，instanceof的模式匹配：</p><ul><li>JDK14作为preview，</li><li>在JDK15作为第二轮的preview，</li><li>在JDK16转正</li></ul></blockquote><h4 id="2-恢复始终严格的浮点语义"><a href="#2-恢复始终严格的浮点语义" class="headerlink" title="2.恢复始终严格的浮点语义"></a>2.恢复始终严格的浮点语义</h4><h4 id="3-增强型伪随机数发生器"><a href="#3-增强型伪随机数发生器" class="headerlink" title="3.增强型伪随机数发生器"></a>3.增强型伪随机数发生器</h4><p>伪随机数生成器（PRNG）提供新的接口类型和实现，使程序使用各种PRNG算法更加容易，更好的支持流式编程。</p><blockquote><p>PRNG伪随机数，随机数会作用于下一个随机数，高效，周期性，确定性等特点，经常用于数学建模等场景。</p></blockquote><p>提供RandomGenerator统一生成PRNG的api，并提供工厂RandomGeneratorFactory生成实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PRNGDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//生成10个10以内的随机数</span></span><br><span class="line">        RandomGeneratorFactory&lt;RandomGenerator&gt; L128X1024MixRandom = RandomGeneratorFactory.of(<span class="string">"L128X1024MixRandom"</span>);</span><br><span class="line">        RandomGenerator randomGenerator = L128X1024MixRandom.create(System.currentTimeMillis());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(randomGenerator.nextInt(<span class="number">10</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="4-macOs渲染管道"><a href="#4-macOs渲染管道" class="headerlink" title="4. macOs渲染管道"></a>4. macOs渲染管道</h4><p><a href="https://openjdk.org/jeps/382" target="_blank" rel="noopener">MACOS支持渲染内容</a></p><p>主要是支持macos的一些ui渲染的支持。为了兼容Apple的渲染管道macOSMetal，Apple准备弃用的OpenGL API作的更新。<br>同时也兼容OpenGL的使用，知道被启用为止。</p><h4 id="5-支持macOS-AArch64平台支持，虚拟机跨平台的支持"><a href="#5-支持macOS-AArch64平台支持，虚拟机跨平台的支持" class="headerlink" title="5. 支持macOS/AArch64平台支持，虚拟机跨平台的支持"></a>5. 支持macOS/AArch64平台支持，虚拟机跨平台的支持</h4><p><a href="https://openjdk.org/jeps/391" target="_blank" rel="noopener">兼容系统的协议</a><br>可将jdk移植到macOS/AArch64，上述系统有（W^X）的策略，禁止内存段同时可执行可写。<br>HotSpot VM定期创建和修改可执行代码，因此JEP将在HotSpot for macOS/AArch64中实现W^X支持。</p><p>人家有用户就是霸气，乙方就得兼容。</p><h4 id="6。删除已弃用Applet-API"><a href="#6。删除已弃用Applet-API" class="headerlink" title="6。删除已弃用Applet API"></a>6。删除已弃用Applet API</h4><p><a href="https://openjdk.org/jeps/398" target="_blank" rel="noopener">APPLET弃用</a><br>稍微介绍一下Applet是什么，为何弃用。</p><blockquote><p>功能： 一般运行在支持Java的Web浏览器，Java客户端的运行浏览器，有自己的生命周期。<br>例如这种，年轻人们是不是没见过，取消这个Applet的生态主要是现在前端生态百花齐放，基本没有运用场景了。</p></blockquote><p><img src="img.png" alt="img.png"></p><h4 id="7-移除RMI"><a href="#7-移除RMI" class="headerlink" title="7.移除RMI"></a>7.移除RMI</h4><p><a href="https://openjdk.org/jeps/407" target="_blank" rel="noopener">Remove RMI Activation</a></p><p>满足好奇心，什么是rmi，下面是demo：</p><p>rmi 是一种远程通信协议，通过接口进行通信。</p><p>server端<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RmiServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建一个远程对象</span></span><br><span class="line">            IRmi rmiHello = <span class="keyword">new</span> RmiImpl();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//远程主机远程对象注册表Registry的实例，并指定端口为8888，这一步必不可少（Java默认端口是1099），</span></span><br><span class="line">            <span class="comment">// 必不可缺的一步，缺少注册表创建，则无法绑定对象到远程注册表上</span></span><br><span class="line">            LocateRegistry.createRegistry(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//把远程对象注册到RMI注册服务器上，并命名为RHello</span></span><br><span class="line">            <span class="comment">//绑定的URL标准格式为：rmi://host:port/name(其中协议名可以省略，下面两种写法都是正确的）</span></span><br><span class="line">            Naming.bind(<span class="string">"rmi://localhost:8888/RmiHello"</span>,rmiHello);</span><br><span class="line">            <span class="comment">//Naming.bind("//localhost:8888/RmiHello",rmiHello);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//必须捕获这三个异常，否则需要在main方法中抛出</span></span><br><span class="line">        &#125;  <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"创建远程对象发生异常"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"URL畸形异常"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AlreadyBoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"重复绑定对象异常"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>client端<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//在RMI服务注册表中查找名称为RHello的对象，并调用其上的方法</span></span><br><span class="line">            IRmi localHello = (IHello)Naming.lookup(<span class="string">"rmi://localhost:8888/RmiHello"</span>);</span><br><span class="line">            System.out.println(localHello.say());</span><br><span class="line">            System.out.println(localHello.sayTo(<span class="string">"11111"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NotBoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="8-密封类"><a href="#8-密封类" class="headerlink" title="8.密封类"></a>8.密封类</h4><p><a href="https://openjdk.org/jeps/409" target="_blank" rel="noopener">Sealed Classes</a></p><p>主要是做接口限制，指定哪些类可以实现或者扩展。</p><p><code>sealed</code>声明密封类， <code>permits</code>声明可以继承的类；<br>仅有 <code>Circle</code>,<code>Rectangle</code>,<code>Square</code>可以继承<code>Shape</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> sealed <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span></span><br><span class="line"><span class="class">    <span class="title">permits</span> <span class="title">Circle</span>,</span></span><br><span class="line"><span class="class">            <span class="title">Rectangle</span>,</span></span><br><span class="line"><span class="class">            <span class="title">Square</span> </span>&#123;  &#125;</span><br></pre></td></tr></table></figure></p><p>// todo</p><h4 id="9-移除AOT及JIT-Compiler"><a href="#9-移除AOT及JIT-Compiler" class="headerlink" title="9.移除AOT及JIT Compiler"></a>9.移除AOT及JIT Compiler</h4><p><a href="https://openjdk.java.net/jeps/410" target="_blank" rel="noopener">Remove the Experimental AOT and JIT Compiler</a></p><p>原本的Java编译流程是JIT编译</p><p>AOT 提前编译，优化spring框架启动慢，占用内存多的特性，垃圾无法被回收问题。</p><p>spring Native基于Graal VM编译成原生镜像，云原生友好</p><h4 id="10-废弃Security-Manager"><a href="#10-废弃Security-Manager" class="headerlink" title="10.废弃Security Manager"></a>10.废弃Security Manager</h4><p><a href="https://openjdk.org/jeps/411" target="_blank" rel="noopener">Deprecate the Security Manager for Removal</a></p><p>这个是从java1.0保护客户端的代码，服务于Applet。也是由于发展原因随着Applet一起被删除。</p><h4 id="11-外部函数和内存API"><a href="#11-外部函数和内存API" class="headerlink" title="11.外部函数和内存API"></a>11.外部函数和内存API</h4><p><a href="https://openjdk.java.net/jeps/412" target="_blank" rel="noopener">Foreign Function &amp; Memory API (Incubator)</a></p><p>新的API，Java程序可以与Java运行时之外的代码和数据进行互操作。通过有效地调用外部函数（即JVM外部的代码），并安全地访问外部内存（即不由JVM管理的内存），API使Java程序能够调用本地库并处理本地数据，而不会出现JNI的脆弱性和危险。</p><p>以前是通过JNI去调用C++/C代码取跟内存进行交互的，这里是指JVM内存结构内<code>堆</code>以外的内存，现在提供一套API替换JNI的功能</p><ul><li>易用性，相对于JNI更容易使用，java开发的模型对象</li><li>性能与现有的JNI与<code>sun.misc.Unsafe</code>相比不差</li><li>安全性上，默认禁用不安全操作</li></ul><blockquote><p>分配外部内存:MemorySegment，MemoryAddress，SegmentAllocator</p><p>操作和访问结构化外部内存：MemoryLayout，MemoryHandles，MemoryAccess</p><p>管理外部资源的生命周期：ResourceScope</p><p>调用外部函数 SymbolLookup，CLinker </p></blockquote><p>举例子<br>如<code>MemorySegment</code> 连续内存的模型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (MemorySegment segment = MemorySegment.allocateNative(<span class="number">100</span>)) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = StreamSupport.stream(MemorySegment.spliterator(segment.withOwnerThread(<span class="keyword">null</span>),seq_bulk),<span class="keyword">true</span>)</span><br><span class="line">                    .mapToInt(slice -&gt; &#123;</span><br><span class="line">                        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span> ; i++) &#123;</span><br><span class="line">                            res += MemoryAccess.getIntAtIndex(slice, i);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> res;</span><br><span class="line">                    &#125;).sum();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12-矢量API"><a href="#12-矢量API" class="headerlink" title="12.矢量API"></a>12.矢量API</h4><p><a href="https://openjdk.java.net/jeps/414" target="_blank" rel="noopener">Vector API (Second Incubator)</a></p><p>向量API是从JDK16开始引入的。<br>向量相关定义API,三维向量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VectorDemo</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> VectorSpecies&lt;Float&gt; SPECIES = FloatVector.SPECIES_256;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">vectorComputation</span><span class="params">(<span class="keyword">float</span>[] a, <span class="keyword">float</span>[] b, <span class="keyword">float</span>[] c)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i += SPECIES.length()) &#123;</span><br><span class="line">            <span class="keyword">var</span> m = SPECIES.indexInRange(i, a.length);</span><br><span class="line">            <span class="comment">// FloatVector va, vb, vc;</span></span><br><span class="line">            <span class="keyword">var</span> va = FloatVector.fromArray(SPECIES, a, i, m);</span><br><span class="line">            <span class="keyword">var</span> vb = FloatVector.fromArray(SPECIES, b, i, m);</span><br><span class="line">            <span class="keyword">var</span> vc = va.mul(va).</span><br><span class="line">                    add(vb.mul(vb)).</span><br><span class="line">                    neg();</span><br><span class="line">            vc.intoArray(c, i, m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><font color=A31212>个人感觉应用不多，忽略忽略</font><h4 id="13-实现特定于上下文的反序列化过滤器"><a href="#13-实现特定于上下文的反序列化过滤器" class="headerlink" title="13.实现特定于上下文的反序列化过滤器"></a>13.实现特定于上下文的反序列化过滤器</h4><p><a href="https://openjdk.java.net/jeps/415" target="_blank" rel="noopener">Context-Specific Deserialization Filters</a></p><blockquote><p>对不受信任的数据进行反序列化是一种固有的危险活动，因为传入数据流的内容决定了创建的对象、其字段的值以及它们之间的引用。 </p><p>在许多典型的使用中，流中的字节是从未知、不可信或未经身份验证的客户端接收的。 </p><p>通过小心地构造流，对手可能会导致恶意执行任意类中的代码。 </p><p>如果对象构造有改变状态或调用其他操作的副作用，这些操作可能会危及应用程序对象、库对象甚至Java运行时的完整性。 </p><p>关键是防止任意类的实例被反序列化，从而防止直接或间接地执行它们的方法。</p></blockquote><p>简而言之，就是在数据流在反序列化之前可以通过自定义过滤器去做校验，验证这个数据的安全性。<br>原本JDK9引入了数据流的反序列化功能，就是嫌弃流操作太麻烦了，jdk17又提供了API形式的反序列化类。<br>如<code>BinaryOperator&lt;ObjectInputFilter&gt;</code>。</p><hr><div align="center"><font color = orange>你的支持是我加班的动力</font><br/><strong>微信</strong><br/><img src="https://yycreate.github.io/img/wxzf.jpg" style="width:256px;"/><strong>支付宝</strong><br/><img src="https://yycreate.github.io/img/zfbzf_1.jpg" style="width:256px;"/></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>电商需求</title>
      <link href="/user-shop/"/>
      <url>/user-shop/</url>
      
        <content type="html"><![CDATA[<h3 id="1-电商分类"><a href="#1-电商分类" class="headerlink" title="1. 电商分类"></a>1. 电商分类</h3><ul><li>搜索电商</li><li>内容电商</li><li>私域电商</li></ul><h3 id="3-营销模型"><a href="#3-营销模型" class="headerlink" title="3. 营销模型"></a>3. 营销模型</h3><h4 id="6W2H分析法"><a href="#6W2H分析法" class="headerlink" title="6W2H分析法"></a>6W2H分析法</h4><ol><li>目标(which)——选择对象：目标群体是什么，寻找内容的无聊用户；还是有硬刚需的用户；<blockquote><p>前者需要创建需求，对商品的认同，需求，后者则是从生活中发现需求的痛点。（痛点收集的体系）</p></blockquote></li><li>原因(why )——选择理由：为什么要选择该产品，该产品有什么优势，有什么生态；或者说有什么特点。</li><li>对象(what)——功能与本质：用户群体区分，用户为了完成什么事情，使用该产品。</li><li>场所(where)——什么地点：在什么地点，用户选择地点倾向，如有什么营销场地，推广会比较有效果。</li><li>时间和程序(when)——什么时候：</li><li>组织或人(who)——责任单位、责任</li><li>如何做（how to do）——如何提高效率</li><li>价值(how much)——预算是多少</li></ol><h4 id="AIPL模型"><a href="#AIPL模型" class="headerlink" title="AIPL模型"></a>AIPL模型</h4><p><em>适合品牌销售的营销模型</em></p><ol><li>A（Awereness）:品牌认知人群。主要有品牌广告曝光，页面浏览，品类词搜索人群</li><li>I（Interest）：品牌兴趣人群。主要有品牌点击广告，参与品牌互动加购收藏人群</li><li>P（purchase）：品牌购买人群。品牌购买人群</li><li>L（Loyalty）：品牌忠诚人群。复购、评论、分享人群</li></ol><h4 id="FAST模型"><a href="#FAST模型" class="headerlink" title="FAST模型"></a>FAST模型</h4><ol><li>F（Fertility）可运营人群数量-活跃消费者</li><li>A（Advancing）人群转化力-关系周加深率</li><li>S（Superiority）高价值人群总量-会员总量</li><li>T（Thriving）高价值人群活跃度-会员活跃率</li></ol><h4 id="GROW模型"><a href="#GROW模型" class="headerlink" title="GROW模型"></a>GROW模型</h4><ol><li>渗透力（Gain）</li><li>复购力（Retain）</li><li>价格力（Boost）</li><li>延伸力（Widen）</li></ol><h4 id="数据分析6步法"><a href="#数据分析6步法" class="headerlink" title="数据分析6步法"></a>数据分析6步法</h4><ol><li>设计方案</li><li>数据收集</li><li>数据处理</li><li>数据分析</li><li>输出呈现</li><li>编制报告</li></ol><h4 id="KISS复盘法"><a href="#KISS复盘法" class="headerlink" title="KISS复盘法"></a>KISS复盘法</h4><ol><li>Keep（可以保持的）</li><li>Improve（需要改进的）</li><li>Start（需要开始的）</li><li>Stop（需要停止的）</li></ol><h4 id="PDCA循环"><a href="#PDCA循环" class="headerlink" title="PDCA循环"></a>PDCA循环</h4><blockquote><ol><li>P（Plan）—计划<br>确定方针和目标，确定活动计划</li><li>D（Do）—执行<br>实地去做，实现计划中的内容</li><li>C（Check）—检查<br>总结执行结果，注意效果，找出问题</li><li>A（Action）—行动<br>对总结检查的结果进行处理，成功的经验加以肯定并适当推广、标准化；失败的教训加以总结，以免重现，未解决的问题放到下一个PDCA循环</li></ol></blockquote><p>特点：</p><ul><li>周而复始</li><li>大环带小环 (职责分工)</li><li>阶梯式上升</li><li>统计的工具</li></ul><p>八大步骤：</p><ol><li>分析现状、发现问题</li><li>分析影响因素 </li><li>分析主要因素</li><li>采取措施<ol><li>采取5W1H：第一个W是Why，为什么要做这个事情，这是最重要的，为什么要制定这个措施？第二个W是What，我们要到哪里去？我们要执行什么目标？第三个W是Where，在哪个地方做？第四个W是Who，谁来负责完成？第五个W是When，什么时间完成？<br>这些5W1H，都要在我们的计划里面出现，要考虑这五个问题。</li></ol></li><li>执行</li><li>检查</li><li>标准化</li><li>把没有解决或新出现的问题转入下一个PDCA循环中去解决</li></ol><h4 id="sCQA模型"><a href="#sCQA模型" class="headerlink" title="sCQA模型"></a>sCQA模型</h4><p>&gt;</p><h3 id="4-电商工具痛点"><a href="#4-电商工具痛点" class="headerlink" title="4.电商工具痛点"></a>4.电商工具痛点</h3><p>分析工具</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vm-PRNG</title>
      <link href="/vm-PRNG/"/>
      <url>/vm-PRNG/</url>
      
        <content type="html"><![CDATA[<p>PRNG算法</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Xn+<span class="number">1</span> = (aXn + c) mod m</span><br><span class="line">where X <span class="keyword">is</span> the sequence of pseudo-random values</span><br><span class="line">m, <span class="number">0</span> &lt; m  - modulus </span><br><span class="line">a, <span class="number">0</span> &lt; a &lt; m  - multiplier</span><br><span class="line">c, <span class="number">0</span> ≤ c &lt; m  - increment</span><br><span class="line">x0, <span class="number">0</span> ≤ x0 &lt; m  - the seed <span class="keyword">or</span> start value</span><br></pre></td></tr></table></figure><p><a href="https://www.imangodoc.com/92394.html" target="_blank" rel="noopener">参考</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>G1 与 ZGC 的全过程解析</title>
      <link href="/vm-g1-zgc/"/>
      <url>/vm-g1-zgc/</url>
      
        <content type="html"><![CDATA[<h3 id="1-JDK16-JVM相关的改动"><a href="#1-JDK16-JVM相关的改动" class="headerlink" title="1.JDK16 JVM相关的改动"></a>1.JDK16 JVM相关的改动</h3><h4 id="ZGC-并发栈处理"><a href="#ZGC-并发栈处理" class="headerlink" title="ZGC 并发栈处理"></a>ZGC 并发栈处理</h4><p>// todo 待一篇详细ZGC的流程场景</p><h4 id="弹性元数据"><a href="#弹性元数据" class="headerlink" title="弹性元数据"></a>弹性元数据</h4><p>及时的将 HotSpot 中无用的元数据(metaspace)内存还给操作系统，减少元数据的内存占用。</p><hr><p>大概介绍一下垃圾处理器的种类与处理流程</p><h3 id="1-G1-Garbage-First-垃圾回收器"><a href="#1-G1-Garbage-First-垃圾回收器" class="headerlink" title="1.G1 (Garbage-First)垃圾回收器"></a>1.G1 (Garbage-First)垃圾回收器</h3><blockquote><p>jdk8起才支持G1垃圾回收器，启动参数添加 -XX:+UseG1GC</p></blockquote><h4 id="G1垃圾回收器的主要流程"><a href="#G1垃圾回收器的主要流程" class="headerlink" title="G1垃圾回收器的主要流程"></a>G1垃圾回收器的主要流程</h4><p>G1的堆内存结构，不做物理分区，仅做逻辑分区：</p><p><img src="https://yycreate.github.io/img/image/gc/G1_heap_style.png" alt="img_1.png"></p><p>Eden: 默认占用堆内存的5%；可以通过-XX:G1NewSizePercent调整年轻代的占比。</p><p>Humongous: 大对象存储区，在MixedGC或Full gc的时候会回收。<br>大对象: 当一个对象的大小超过了一个Region区域的50%</p><p>G1垃圾回收主要分为两个阶段，年轻代回收（young-only）和空间回收阶段（space reclamation），不断交替进行。</p><p><code>这是一个周期性事件，达到某些要求会进行GC，所有情况都是跟着用户进程同时进行的。</code></p><hr><h5 id="年轻代回收"><a href="#年轻代回收" class="headerlink" title="年轻代回收"></a><strong><font color=#329999>年轻代回收</font></strong></h5><p><font color=#329999><br>    G1会创建回收集（collection set），记录需要被回收的内存分段的集合，年轻代回收过程的回收集包含Eden和Survivor所有内存段。</font><br><br/></p><h5 id="如何记录回收集以及回收流程"><a href="#如何记录回收集以及回收流程" class="headerlink" title="如何记录回收集以及回收流程"></a>如何记录回收集以及回收流程</h5><p>注：每个Region初始化时，会初始化一个remembered set（已记忆集合）简称RSet，该集合用来记录并跟踪其它Region指向该Region中对象的引用。<br>每个Region默认按照512Kb划分成多个Card，所以RSet需要记录的东西应该是 xx Region的 xx Card。</p><blockquote><p>1.扫描根</p><p>static变量指向对象，正在执行方法调用链的局部对象。引用与RSet记录的外部引用，作为扫描入口</p></blockquote><p>RSet数据，在每个Region中。<br><img src="https://yycreate.github.io/img/image/gc/region_RSET.png" alt="img_1.png"></p><blockquote><p>2.更新RSet<br>处理dirty card queue中的card，更新RSet。反应老年代对应内存分段中对象引用。</p></blockquote><p>dirty card queue在每个Java线程都有，方法所使用内存标志为duty，插入到队列中；全局也有个queue共享某部分card。</p><blockquote><p>3.处理RSet</p><p>识别被老年代对象指向的Eden中的对象,这些被指向的Eden中的对象被认为是存活的对象。</p><p>4.复制对象</p><p>此阶段,对象树被遍历,Eden区内存段中存活的对象会被复制到Survivor区中空的内存分段,Survivor区内存段中存活的对象如果年龄未达阈值,年龄会加1,达到阈值会被复制到Old区中空的内存分段。如果Survivor空间不够,Eden空间的部分数据会直接晋升到老年代空间。</p><p>5.处理引用</p><p>处理Soft,Weak,Phantom,Final,JNI Weak 等引用。Eden空间的数据清空,GC停止工作,而目标内存中的对象连续存储的,没有碎片,复制过程可以达到内存整理的效果。</p></blockquote><h5 id="并发标记过程"><a href="#并发标记过程" class="headerlink" title="并发标记过程"></a><strong><font color=#329999>并发标记过程</font></strong></h5><ul><li>初始标记阶段: 标记从根节点直接可达的对象。这个阶段是STW的,并且会触发一次年轻代GC。 </li><li>根区域扫描(Root Region Scanning): G1 GC扫描survivor区直接可达的老年代区域对象,并标记被引用的对象。这一过程必须在young GC之前完成。 </li><li>并发标记(Concurrent Marking): 在整个堆中进行并发标记(和应用程序并发执行),此过程可能被young GC中断。在并发标记阶段,若发现区域对象中的所有对象都是垃圾,那这个区域会被立即回收。同时,并发标记过程中,会计算每个区域的对象活性(区域中存活对象的比例)。 </li><li>再次标记(Remark): 由于应用程序持续进行,需要修正上一次的标记结果。是STW的。G1中采用了比CMS更快的初始快照法: snapshot-at-the-beginning(SATB)。 </li><li>独占清理(cleanup,STW): 计算各个区域的存活对象和GC回收比例,并进行排序,识别可以混合回收的区域。</li><li>并发清理阶段: 识别并清理完全空闲的区域。</li></ul><p>如图所示，回收的流程：<br><img src="https://yycreate.github.io/img/image/gc/G1_step.png" alt="img_1.png"></p><h5 id="混合回收（Mixed-GC）"><a href="#混合回收（Mixed-GC）" class="headerlink" title="混合回收（Mixed GC）"></a><strong><font color=#329999>混合回收（Mixed GC）</font></strong></h5><p>当更多的对象晋升到老年代old region时,为了避免堆内存被耗尽,虚拟机会触发一个混合的垃圾收集器,即Mixed GC。</p><p>该算法并不是一个Old GC,除了回收整个Young Region,还会回收一部分的Old Region。</p><h5 id="FULL-GC"><a href="#FULL-GC" class="headerlink" title="FULL GC"></a><strong><font color=#329999>FULL GC</font></strong></h5><p>G1初衷是要避免Full GC发生。</p><p>上门的GC无法正常完成GC回收，G1会STW并使用单线程算法进行垃圾回收，性能很差。</p><p>以下两种会调起Full GC</p><ul><li>Evacuation的时候没有足够的to-space来存放晋升的对象。</li><li>并发处理完成之前空间耗尽。</li></ul><h4 id="三色算法-STAB-snapshot-at-the-beginning"><a href="#三色算法-STAB-snapshot-at-the-beginning" class="headerlink" title="三色算法 STAB(snapshot-at-the-beginning)"></a>三色算法 STAB(snapshot-at-the-beginning)</h4><p>使用情况实在并发标记情况下：<br>//todo</p><hr><h3 id="2-ZGC-垃圾回收器"><a href="#2-ZGC-垃圾回收器" class="headerlink" title="2.ZGC 垃圾回收器"></a>2.ZGC 垃圾回收器</h3><h3 id="JDK升级对各个垃圾回收器的优化，以及性能不叫"><a href="#JDK升级对各个垃圾回收器的优化，以及性能不叫" class="headerlink" title="JDK升级对各个垃圾回收器的优化，以及性能不叫"></a>JDK升级对各个垃圾回收器的优化，以及性能不叫</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>graal vm</title>
      <link href="/vm-graal-VM/"/>
      <url>/vm-graal-VM/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.graalvm.org/" target="_blank" rel="noopener">官网</a></p><h3 id="一-共识"><a href="#一-共识" class="headerlink" title="一.共识"></a>一.共识</h3><p>在JVM的hotspot实现上增强的的全栈型虚拟机。<br>虚拟机支持原本Java虚拟机上的Java、Scala、Groovy、Kotlin<br>还支持基于LLVM的C、C++、Rust<br>还支持其他像JavaScript、Ruby、Python和R语言<br>可以无额外开销地混合使用这些编程语言，支持不同语言中混用对方的接口和对象。</p><h3 id="二-安装"><a href="#二-安装" class="headerlink" title="二. 安装"></a>二. 安装</h3><h4 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h4><h4 id="云上环境"><a href="#云上环境" class="headerlink" title="云上环境"></a>云上环境</h4><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>电商</title>
      <link href="/shop/"/>
      <url>/shop/</url>
      
        <content type="html"><![CDATA[<h3 id="电商模式"><a href="#电商模式" class="headerlink" title="电商模式"></a>电商模式</h3><p>搜索电商 人找货</p><blockquote><p>主要解决生活刚需</p></blockquote><p>内容电商 货找人</p><blockquote><p>挖掘用户需求</p></blockquote><p>私域电商 人找人</p><blockquote><p>社交消费，寻找电商需求</p></blockquote><h3 id="2-运营"><a href="#2-运营" class="headerlink" title="2. 运营"></a>2. 运营</h3><ul><li>卖给谁：用户画像视角</li><li>类目，sku，用户喜好，竞品分析，供应链，促销</li><li>内容喜好</li><li>用户评价，品牌增长（基于产品的用户习惯）</li><li>消费者消费状态是动态的</li></ul><h3 id="买卖家需求-电商本质"><a href="#买卖家需求-电商本质" class="headerlink" title="买卖家需求 - 电商本质"></a>买卖家需求 - 电商本质</h3><ul><li>可接收信息数量质量，决策</li><li>愉悦度，所见即所得，物流体验感，品牌虚荣等等，多快好省</li><li>生态，数字化工具升级</li><li>买家需求 - 多快好省</li><li>卖家需求（品牌商家）- 品牌定位，品牌溢价<blockquote><p>品牌商家增多了，传统搜索电商生命周期加速。<br>拼多多，社交生态，吸引商家（中小型），下沉市场，中老年</p></blockquote></li></ul><h3 id="营销模型"><a href="#营销模型" class="headerlink" title="营销模型"></a>营销模型</h3><ul><li>5A 模型</li><li>AIPL 模型 - 精英模型，抓不到用户喜好</li><li>FACV 品牌电商，自播/达人矩阵/营销活动/头部大V <blockquote><p>抖音会根据达人触达很多用户，让人贵得有道理，品牌溢价;<br>以内容为主，无明确购物需求;<br>营销活动；</p></blockquote></li><li><p>3M模型 观察-打造模型-模型落地</p></li><li><p>决策效率</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>分布式 ID 项目</title>
      <link href="/service-gen-id/"/>
      <url>/service-gen-id/</url>
      
        <content type="html"><![CDATA[<h4 id="场景假设"><a href="#场景假设" class="headerlink" title="场景假设"></a>场景假设</h4><blockquote><p>什么是分布式ID呢？ 国家要每天的出生婴儿要发放身份证，为了保证每个地区每天出生的每个新生儿的身份证号码是唯一的。身份证号码就是分布式ID。</p></blockquote><h4 id="主要实现功能："><a href="#主要实现功能：" class="headerlink" title="主要实现功能："></a>主要实现功能：</h4><ul><li>分布式项目获取ID唯一</li><li>实现高可用及动态扩展</li><li>如何压榨服务器资源</li></ul><h4 id="一、-如何保持-ID-的唯一"><a href="#一、-如何保持-ID-的唯一" class="headerlink" title="一、 如何保持 ID 的唯一"></a>一、 如何保持 ID 的唯一</h4><p>确定得到得主键ID是全局唯一需要保证ID含有这些要素：</p><ul><li>时间戳，在单个节点中全局唯一且自增</li><li>节点ID，当应用服务作负载均衡得时候，每个服务有分发不唯一得ID</li><li>自增随机数，根据业务需求量调整<br><img src="https://img-blog.csdnimg.cn/bc9822e8239143089d123e955c89baf6.png" alt="在这里插入图片描述"><br>解释：<br>节点ID在集群环境是<code>全局唯一</code>的；时间戳在每个节点中是唯一的，是<code>局部唯一</code>的；自增随机数为自增数，则为<code>业务场景递增数</code>；满足这三个条件才可以成为分布式ID；</li></ul><h4 id="二、生成分布式ID的流程"><a href="#二、生成分布式ID的流程" class="headerlink" title="二、生成分布式ID的流程"></a>二、生成分布式ID的流程</h4><h5 id="2-1-架构图"><a href="#2-1-架构图" class="headerlink" title="2.1 架构图"></a>2.1 架构图</h5><ul><li>IDGen-service 为分布式ID服务</li><li>NGINX 支持服务横向扩展</li><li>zookeeper 主要完成三个功能：<br><code>业务主键注册</code>（记录每种业务的自增数最大记录），<code>分发服务的 nodeId</code> (保证每个服务的nodeId不一致) 和 <code>每个节点的时钟校验</code>（防止服务发生时钟回拨）<br><img src="https://img-blog.csdnimg.cn/3a26a41e117a49e38a93d3d575ed3edf.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MDMzNzcw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h5 id="2-2-业务参数组件"><a href="#2-2-业务参数组件" class="headerlink" title="2.2 业务参数组件"></a>2.2 业务参数组件</h5>上一点说到，每种业务都需要注册到 zookeeper 中，主要包含这几个参数：</li><li>maxId 最大的自增数</li><li>step 步长，ID并不会每需要一个生成一个，服务中会有ID池，步长则是ID池的容量</li><li>time 更新时间和创建时间，当不同的节点申请同一个业务资源时，申请完成后更新时间；创建时间则是个记录而已</li><li>key 表示用于不同业务的标识<br><img src="https://img-blog.csdnimg.cn/0360b233f2ac414ebe98a86c4249f1f0.png" alt="在这里插入图片描述"><h5 id="2-3-ID-缓存对象"><a href="#2-3-ID-缓存对象" class="headerlink" title="2.3 ID 缓存对象"></a>2.3 ID 缓存对象</h5>ID-Gen 接口<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IDGen</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> </span></span><br><span class="line"><span class="comment">     * key 业务id</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function">String <span class="title">get</span><span class="params">(String key)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>实现:<br>从 <code>cache</code> 中获取对应的业务主键，没有则不支持这个业务生成主键；<code>cache</code> 中每个业务key的操作要保证原子性。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 业务key的 JVM 缓存</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, SegmentBuffer&gt; cache;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(String businessId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cache.containsKey(businessId)) &#123;</span><br><span class="line">            SegmentBuffer buffer = cache.get(businessId);</span><br><span class="line">            <span class="comment">// 获取id的原子操作，锁住该业务</span></span><br><span class="line">            <span class="keyword">synchronized</span> (buffer) &#123;</span><br><span class="line">                <span class="comment">// segmentBuffer 更新 zookeeper 持久化数据</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.getIdFromBufferPool(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ServiceErrorException(<span class="string">"service zk 并没有该业务组件主键"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p>buffer 对象（含ID池，以及生产ID的策略，以及对该资源操作的锁 lock）</p><ul><li>setIdInPool 方法在项目初始化时，会设置 step 长度的线程池</li><li>bufferQueue 队列就是新的ID池，在加载的时候要注意对zk资源加锁并更新</li><li>idPool 为当期对象的 id 池，当id池达到某个阈值是可以往 <code>bufferQueue</code> 加入新的 ID<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SegmentBuffer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nextBufferIsReady = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">this</span>.lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">        <span class="keyword">this</span>.threadRunning = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 设置 id 池</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="keyword">this</span>.setIdInPool();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * buffer 队列，用完一个，下一个接着</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;SegmentBuffer&gt; bufferQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * id 池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;String&gt; idPool;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPoolSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> idPool.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * buffer组，预加载的buffer （多线程加入就不会影响该对象的速度）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> SegmentBuffer[] segments;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下一个id池 是否已完成加载</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> nextBufferIsReady = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * zk 记录参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    <span class="keyword">private</span> Long step;</span><br><span class="line">    <span class="keyword">private</span> Long maxId;</span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createTime;</span><br><span class="line">    <span class="keyword">private</span> LocalDateTime updateTime;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前使用到的id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> AtomicInteger currentIndex = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 当前最大的 id</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> AtomicReference&lt;String&gt; currentIdString = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取 id 时加锁，只有一个线程能获取到 id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ReadWriteLock lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 线程是否在运行中</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">private</span> AtomicBoolean threadRunning;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**************</span></span><br><span class="line"><span class="comment">     * 生成策略相关</span></span><br><span class="line"><span class="comment">     * **</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long serverNodeNumber = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Long <span class="title">nowTimeStamp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * id 生成策略</span></span><br><span class="line"><span class="comment">     * （算法还再考虑，策略模式导入方法， 策略类 + 实现 ）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> IdGenStrategy idGen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 需的参数：</span></span><br><span class="line"><span class="comment">     * - 时间戳（nowTimeStamp） + 分发的节点随机数（serverNodeNumber） + 当前数字（currentIndex）</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIdInPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        idPool = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line">        bufferQueue = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line">        CommonThreadUtil.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; step; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Objects.isNull(idGen)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IdCreateErrorException(<span class="string">"id 的生成策略为空"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                String nowId = idGen.createId(nowTimeStamp(), serverNodeNumber, currentIndex.getAndIncrement());</span><br><span class="line">                idPool.add(nowId);</span><br><span class="line">                currentIdString.set(nowId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNewSegmentBufferInQueue</span><span class="params">(SegmentBuffer buffer)</span> </span>&#123;</span><br><span class="line">        bufferQueue.add(buffer);</span><br><span class="line">        <span class="keyword">this</span>.nextBufferIsReady = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNextId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !idPool.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">nextId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> idPool.poll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="2-4-业务-ID-的预加载"><a href="#2-4-业务-ID-的预加载" class="headerlink" title="2.4 业务 ID 的预加载"></a>2.4 业务 ID 的预加载</h5><p><img src="https://img-blog.csdnimg.cn/d5126fa08e0e450fbfb263b28b6a7170.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MDMzNzcw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><code>businessKeys</code> 是配置在 yaml 的配置的节点信息，在这种设置的同时会有一个动态拓展业务key的问题，但可以通过新的集群加入新的 <code>key</code> 承载新的业务，使用同一个 <code>zk集群</code> 是不冲突的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BusinessKeyConfigBean businessKeys;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> InitializeServiceImpl initializeService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * cache 初始化的组件使用 application.yaml 的 business.key 中的值初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"cache"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, SegmentBuffer&gt; <span class="title">getCache</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Map&lt;String, SegmentBuffer&gt; cache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">        log.info(<span class="string">"加载业务组件数量 &#123;&#125;"</span>, businessKeys.getKey().size());</span><br><span class="line">        <span class="keyword">int</span> size = businessKeys.getKey().size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            String key = businessKeys.getKey().get(i);</span><br><span class="line">            <span class="keyword">if</span> (!cache.containsKey(key)) &#123;</span><br><span class="line">                cache.put(key, initializeService.setBufferInZk(key, businessKeys.getNode()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cache;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  .... yaml 配置</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"business"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessKeyConfigBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long node;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; key;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-5-获取-ID-的主流程"><a href="#2-5-获取-ID-的主流程" class="headerlink" title="2.5 获取 ID 的主流程"></a>2.5 获取 ID 的主流程</h5><p>主流程图：<br><img src="https://img-blog.csdnimg.cn/950f7e0b6bcc44eea4b407ec3d1c2b3f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MDMzNzcw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="三、如何压榨服务器流程"><a href="#三、如何压榨服务器流程" class="headerlink" title="三、如何压榨服务器流程"></a>三、如何压榨服务器流程</h4><ul><li>对象的锁要细粒度化</li><li>只对业务资源锁，然后使用多线程完成剩余的代码逻辑</li><li>使用无锁来优化代码，无锁能提高效率，却消耗服务器资源</li></ul><h4 id="终：-优化点，如何提高分布式ID的并发量"><a href="#终：-优化点，如何提高分布式ID的并发量" class="headerlink" title="终： 优化点，如何提高分布式ID的并发量"></a>终： 优化点，如何提高分布式ID的并发量</h4><ol><li>优化业务参数（ID池的容量与下一个ID池的加载阈值）</li><li>启动多线程加载新的线程池（待解决问题，新的ID池加载完成前，ID池已空）</li></ol><p><a href="https://gitee.com/yycreate/grains_v1" target="_blank" rel="noopener">gitee代码地址</a></p><hr><div align="center"><font color = orange>你的支持是我加班的动力</font><br/><strong>微信</strong><br/><img src="https://yycreate.github.io/img/wxzf.jpg" style="width:256px;"/><strong>支付宝</strong><br/><img src="https://yycreate.github.io/img/zfbzf_1.jpg" style="width:256px;"/></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>redis整理场景以及使用</title>
      <link href="/redis-redis-main/"/>
      <url>/redis-redis-main/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#零.共识">0.共识</a></li><li><a href="#一.redis部署架构">1.redis部署架构</a></li><li><a href="#二.适用场景">2.适用场景</a></li><li><a href="#三.实际问题及其解决方案">3.实际问题及其解决方案</a></li><li><a href="#四.压测方案及容灾方案">4.压测方案及容灾方案</a></li><li><a href="#五.数据迁移与备份">5.数据迁移与备份</a></li></ul><h3 id="零-共识"><a href="#零-共识" class="headerlink" title="零.共识"></a>零.共识</h3><p>查询组件单线程，链接多路复用，有事务提交，但不能回滚。</p><h3 id="一-redis部署架构"><a href="#一-redis部署架构" class="headerlink" title="一.redis部署架构"></a>一.redis部署架构</h3><hr><h4 id="1-单机架构"><a href="#1-单机架构" class="headerlink" title="1.单机架构"></a>1.单机架构</h4><p>忽略吧 单机架构有相当多问题</p><ul><li>1.单点问题</li><li>2.多路复用</li><li>3.</li></ul><h4 id="2-哨兵架构"><a href="#2-哨兵架构" class="headerlink" title="2.哨兵架构"></a>2.哨兵架构</h4><p>在部署redis的同时也需要部署哨兵，哨兵主要功能分为：</p><ul><li>监控redis主从节点的运行状况</li><li>当master节点挂了之后，选出master</li></ul><p>部署拓扑<br><img src="https://yycreate.github.io/img/image/redis/sentinel.png" alt="img.png"></p><p>master节点配置<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">### REDIS MASYER</span><br><span class="line">port <span class="number">6379</span></span><br><span class="line">daemonize <span class="keyword">no</span></span><br><span class="line">#logfile <span class="string">"6379.log"</span></span><br><span class="line">dir /redis-<span class="number">4.0</span>.<span class="number">0</span>/data</span><br><span class="line">dbfilename dump-<span class="number">6379</span>.rdb</span><br><span class="line">rdbcompression yes</span><br><span class="line">rdbchecksum yes</span><br><span class="line">save <span class="number">10</span> <span class="number">2</span></span><br><span class="line">appendonly yes</span><br><span class="line">appendfsync always</span><br><span class="line">appendfilename appendonly-<span class="number">6379</span>.aof</span><br><span class="line">bind <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line">databases <span class="number">16</span></span><br></pre></td></tr></table></figure></p><p>slave节点配置<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">### REDIS SLAVE</span><br><span class="line">port <span class="number">6380</span></span><br><span class="line">daemonize <span class="keyword">no</span></span><br><span class="line">#logfile <span class="string">"6380.log"</span></span><br><span class="line">dir /redis-<span class="number">4.0</span>.<span class="number">0</span>/data</span><br><span class="line">slaveof <span class="number">127.0</span>.<span class="number">0.1</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure></p><p>sentinel哨兵节点配置<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">### SENTINEL</span><br><span class="line">port <span class="number">26379</span></span><br><span class="line">dir /redis-<span class="number">4.0</span>.<span class="number">0</span>/data</span><br><span class="line"># 监控 主 连接字符串 哨兵判挂标准（几个哨兵认定他挂了，就判定为主挂了，通常为哨兵数量的一半加一）</span><br><span class="line">sentinel monitor mymaster <span class="number">127.0</span>.<span class="number">0.1</span> <span class="number">6379</span> <span class="number">2</span></span><br><span class="line"># 无响应时间，为挂掉</span><br><span class="line">sentinel down-after-milliseconds mymaster <span class="number">30000</span> </span><br><span class="line"># 主挂了之后，新的主上任同步数据的路线数量，数值越小，对服务器压力越小</span><br><span class="line">sentinel parallel-syncs mymaster <span class="number">1</span> #</span><br><span class="line"># 新主同步数据时，多长时间同步完算有效 （默认 <span class="number">180</span>s）</span><br><span class="line">sentinel failover-timeout mymaster <span class="number">180000</span></span><br></pre></td></tr></table></figure></p><p>自动故障转移<br><img src="https://yycreate.github.io/img/image/redis/sentinel_change.png" alt="sentinel_change.png"></p><blockquote><p>如何选择新的redis主节点呢？</p><p>当master节点跟哨兵过半失联的时候会发生重新选举：</p><p>1.优先级排序，可以根据配置文件的 <code>replicapriority n</code> 来判断优先级，n越小越优先。</p><p>2.复制数量，如果优先级相同，复制偏移量最大的选主（表示复制原master数据最多）</p><p>3.进程id，如果复制数量也相同，就选择进程id最小的那个</p></blockquote><p>数据流动</p><p>// TODO</p><p>spring配置</p><p>// TODO</p><h4 id="集群架构-Cluster"><a href="#集群架构-Cluster" class="headerlink" title="集群架构 Cluster"></a>集群架构 Cluster</h4><p>Redis Cluster是服务器sharding技术，redis3.0开始支持。</p><p>数据会根据slot分配给多个master，对应的master和slave的数据时相同的；<br>当master宕机时候，对应的slave会顶替master位置继续提供服务。</p><blockquote><p>gossip是提供给集群内所有节点的一个数据最终一致性方案，但会根据slot获取对应的数据。</p><p>每个master节点都根据slot分配不同的数据，但由于增加节点/裁撤等等变更会导致slot之间数据迁移，通过gossip协议同步。</p><p>gossip协议是一个随机通信，可以理解为“传染病”，在传播信息同时会有延迟（缺点）</p></blockquote><p>部署拓扑<br><img src="https://yycreate.github.io/img/image/redis/redis_cluster.png" alt="redis_cluster.png"></p><blockquote><p>gossip协议适用场景：新增节点/slot迁移/节点宕机/slave选举为master（slave可以使多个master的从节点）</p><p>gossip 协议包含多种消息，包括 ping，pong，meet，fail 等等。</p></blockquote><p>spring配置</p><p>redission链接cluster<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">spring：</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="comment">#    host: 127.0.0.1</span></span><br><span class="line">    <span class="comment">#    port: 6379</span></span><br><span class="line">    <span class="attr">cluster:</span></span><br><span class="line">      <span class="attr">nodes:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:7001,127.0.0.1:7002,127.0.0.1:7003,127.0.0.1:7004,127.0.0.1:7005,127.0.0.1:7006</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="comment">## Redis数据库索引(默认为0)</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="comment">## 连接池最大连接数（使用负值表示没有限制）</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">100</span></span><br><span class="line">        <span class="comment">## 连接池最大阻塞等待时间（使用负值表示没有限制）</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="number">100000</span></span><br><span class="line">        <span class="comment">## 连接池中的最大空闲连接</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">10</span></span><br><span class="line">        <span class="comment">## 连接池中的最小空闲连接</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br><span class="line">    <span class="comment">## 连接超时时间（毫秒）</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">30000</span></span><br></pre></td></tr></table></figure></p><p>POM依赖<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.12.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>SPRIING REDIS CONFIG<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedissonConfig</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.redis.cluster.nodes&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; nodes;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.redis.password&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.redis.database&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer database;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedissonClient <span class="title">clusterRedisClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Config config = <span class="keyword">new</span> Config();</span><br><span class="line">        ClusterServersConfig clusterServersConfig = config.useClusterServers();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.isBlank(password)) &#123;</span><br><span class="line">            clusterServersConfig.setPassword(password);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 集群状态扫描间隔时间，单位是毫秒</span></span><br><span class="line">        clusterServersConfig.setScanInterval(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">for</span> (String node : nodes) &#123;</span><br><span class="line">            String url = <span class="string">"redis://"</span> + node;</span><br><span class="line">            clusterServersConfig.addNodeAddress(url);</span><br><span class="line">        &#125;</span><br><span class="line">        RedissonClient redissonClient = Redisson.create(config);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> redissonClient;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>codis框架图</p><p>codis 包含 <code>codis-proxy</code>,<code>codis-redis-group</code>,<code>codis-redis</code> 3个组件</p><h3 id="二-适用场景"><a href="#二-适用场景" class="headerlink" title="二.适用场景"></a>二.适用场景</h3><hr><ol><li>缓存</li><li>秒杀</li><li>支付配置</li><li>热点数据</li><li>配置信息</li><li>zset 实现</li><li>redis-hash 两种实现<ol><li></li></ol></li></ol><h3 id="三-实际问题及其解决方案"><a href="#三-实际问题及其解决方案" class="headerlink" title="三.实际问题及其解决方案"></a>三.实际问题及其解决方案</h3><hr><h4 id="1-大key原因及解决方案，为何大key会引起性能问题"><a href="#1-大key原因及解决方案，为何大key会引起性能问题" class="headerlink" title="1. 大key原因及解决方案，为何大key会引起性能问题"></a>1. 大key原因及解决方案，为何大key会引起性能问题</h4><h5 id="1-1-影响性能的主要原因"><a href="#1-1-影响性能的主要原因" class="headerlink" title="1.1 影响性能的主要原因"></a>1.1 影响性能的主要原因</h5><p>1.1.1 占用内存增大：相比于正常的Key，读取大key需要的内存会有所增大，<br>如果像是value中的list不断变大，可能会造成OOM（内存溢出），<br>还有一种就是达到redis设置的最大内存maxmemory值会造成写阻塞或者部分重要的Key被redis的淘汰策略给删除了。</p><ul><li>hash性能问题主要体现在遍历链表，当hash量很大时会存在hash冲突，然后redis要做大量的rehash。</li></ul><p>1.1.2 网络阻塞延迟变大：在读取大key的时候，由于读取的内容较多，占用较大的带宽，造成网络带宽的阻塞，也会影响其他的应用，导致网络阻塞延迟变大。</p><ul><li>主从模式，大key会使内存使用不均匀。</li><li>若key达到M，访问为1000，每秒1000M流量，千兆网卡顶不住。</li><li>排查是否有bigkeys<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 排查大对象</span></span><br><span class="line"> redis-cli -h &#123;ip&#125; -p &#123;port&#125; bigkeys</span><br></pre></td></tr></table></figure></li></ul><p>1.1.3 IO阻塞延迟增大：主流程为单线程，读写时串行的，多个请求过来时，可能因为单个BigKey的原因可能造成IO阻塞延迟。</p><ul><li>swap 如果一个 Redis 实例的内存使用率超过可用最大内存（used_memory &gt; 可用最大内存），那么操作系统开始进行内存和 swap 空间交换，把内存中旧的或不再使用的内容写入硬盘上（硬盘上的这块空间叫 Swap 分区），以便腾出新的物理内存给新页使用。</li><li>fork 子进程，在 RDB 生成和 AOF 重写时，会 fork 一个子进程完成持久化工作，fork持久化与数据集有关</li><li>AOF 刷盘阻塞，开启 AOF，文件刷盘一般每秒一次，硬盘压力过大时，fsync 需要等待写入完成。 查看 redis 日志或 info persistence 统计中的 aof_delayed_fsync 指标。</li></ul><p>1.1.4 BigKey迁移困难:这个问题是出现在Redis集群中，实际上是通过migrate命令来完成的，migrate实际上是通过dump + restore + del三个命令组合成原子命令完成，如果是bigkey，可能会使迁移失败，而且较慢的migrate会阻塞Redis。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## MIGRATE [HOST] [PORT] [DB] [TIMEOUT]</span></span></span><br><span class="line">MIGRATE 127.0.0.1 7777 key 0 1000</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## MIGRATE 相当于 dump del restore</span></span></span><br><span class="line">dump 源实例</span><br><span class="line">del 源实例</span><br><span class="line">restore 目标实例</span><br></pre></td></tr></table></figure></p><hr><h4 id="2-设计方案：一个接口查询100key提高性能"><a href="#2-设计方案：一个接口查询100key提高性能" class="headerlink" title="2. 设计方案：一个接口查询100key提高性能"></a>2. 设计方案：一个接口查询100key提高性能</h4><h5 id="2-1-管道-pipeline-替换普通的set-key-value"><a href="#2-1-管道-pipeline-替换普通的set-key-value" class="headerlink" title="2.1 管道 pipeline 替换普通的set-key-value"></a>2.1 管道 pipeline 替换普通的set-key-value</h5><p>使用pipeline可以减少多次命令执行的网络等待时间，提高多个key操作的相应速率。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PipelineExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"127.0.0.1"</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 获取 Pipeline 对象</span></span><br><span class="line">        Pipeline pipe = jedis.pipelined();</span><br><span class="line">        <span class="comment">// 设置多个 Redis 命令</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            pipe.set(<span class="string">"key"</span> + i, <span class="string">"val"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行命令并返回结果</span></span><br><span class="line">        List&lt;Object&gt; res = pipe.syncAndReturnAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="2-2-内部缓存（不适合数据量大的场景）"><a href="#2-2-内部缓存（不适合数据量大的场景）" class="headerlink" title="2.2 内部缓存（不适合数据量大的场景）"></a>2.2 内部缓存（不适合数据量大的场景）</h5><p>将小量且不变的数据存储在gavua-cache中，不使用网络访问redis，去除不使用建立网络链接的时间，提高速度。</p><hr><h4 id="3-redis集群引发多个key不落在同一个槽位（slot）问题"><a href="#3-redis集群引发多个key不落在同一个槽位（slot）问题" class="headerlink" title="3. redis集群引发多个key不落在同一个槽位（slot）问题"></a>3. redis集群引发多个key不落在同一个槽位（slot）问题</h4><h5 id="3-1-引发原因"><a href="#3-1-引发原因" class="headerlink" title="3.1 引发原因"></a>3.1 引发原因</h5><p>redis在单节点情况下槽位是属于一个片区的，同一个key在hash运算下一定会分配到一个一个节点上。<br>然而在集群模式中，槽位负载均衡到不同的节点上，通过hash计算的key值具体落槽点在不同节点上。<br>同时引起另外的问题，在集群模式中，一个请求多给key进行操作限制在一个slot中，不能跨槽执行。<br>lua脚本对多个key进行操作的时候，key在hash后落在多个slot。会引发“CROSSSLOT Keys in request don‘t hash to the same slot”</p><h5 id="3-2-解决方案"><a href="#3-2-解决方案" class="headerlink" title="3.2 解决方案"></a>3.2 解决方案</h5><p>主要原因：</p><ul><li>业务操作多个key，且key不在同一个节点上<br>解决：</li><li>根据业务不同的key，分别在不同的业务中执行</li><li>可以根据唯一的key将业务属性放在一个map中</li></ul><blockquote><p>槽位(slot)： Redis集群通过分片的方式来保存数据库中的键值对，集群的整个数据库被分为16384个槽，数据库中的每个键都属于这16384个槽的其中一个，集群中的每个节点可以处理0个或最多16384个。</p></blockquote><h3 id="四-压测方案及容灾方案"><a href="#四-压测方案及容灾方案" class="headerlink" title="四.压测方案及容灾方案"></a>四.压测方案及容灾方案</h3><h4 id="容灾方案"><a href="#容灾方案" class="headerlink" title="容灾方案"></a>容灾方案</h4><p>当设计一个中间间架构的时候把其独立起来，上游服务仅是调用，使中间件的扩展与维护对于服务来说是无感的，类似于laas服务。</p><p>然而设计一个这样的中间间架构需要多层的服务。</p><h5 id="接入层：LVS-DNS"><a href="#接入层：LVS-DNS" class="headerlink" title="接入层：LVS/DNS"></a>接入层：LVS/DNS</h5><ul><li>基于NAT的LVS模式负载均衡</li><li>基于TUN的LVS负载均衡</li><li>基于DR的LVS负载均衡</li></ul><h5 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h5><p>可拆分为局部状态</p><ul><li>分号段分区，降低影响面</li><li>备份部署，直接快速切换</li><li>可实施有损服务等应用<br>优点：取决业务柔性及部署合理性，开发时间投入少。<br>缺点：部署不合理会导致灾难时损失倍增。</li></ul><h5 id="数据层"><a href="#数据层" class="headerlink" title="数据层"></a>数据层</h5><p>一致性强应用<br>优点；保障上层数据完整<br>缺点：技术实现复杂，然而使用的机器资源很大</p><p>redis持久化的两种方式：</p><ul><li>RDB 指定时间间隔数据快照储存。</li><li>AOF 记录服务器写操作。服务器重启时重新执行。（redis支持后台重写AOF，减少AOF文件大小）</li></ul><p>RDB持久化</p><blockquote><p>镜像全量持久化</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## 主线程执行，会阻塞</span></span></span><br><span class="line">save</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## 子程执行，redis默认配置</span></span></span><br><span class="line">bgsave</span><br></pre></td></tr></table></figure><p>fork 使子进程同步父进程的共享数据块，当一个子进程fork时，别的子进程访问时会直接返回<br><img src="https://yycreate.github.io/img/image/redis/fork.png" alt="img.png"></p><p>COW(copy on write)操作，子进程创建之后，父子进程共享数据段，父进程继续提供读写服务，将子进程脏写的数据清理<br><img src="https://yycreate.github.io/img/image/redis/cow.png" alt="img.png"></p><ul><li>执行 bgsave 命令，Redis 父进程判断当前是否存在正在执行的子进 程，如 RDB/AOF 子进程，如果存在bgsave命令直接返回。</li><li>父进程执行 fork 操作创建子进程，fork 操作过程中父进程会阻塞，通 过 info stats 命令查看 latest_fork_usec 选项，可以获取最近一个 fork 操作的耗 时，单位为微秒。</li><li>父进程fork完成后，bgsave 命令返回 “Background saving started” 信息 并不再阻塞父进程，可以继续响应其他命令。</li><li>子进程创建 RDB 文件，根据父进程内存生成临时快照文件，完成后 对原有文件进行原子替换。执行lastsave命令可以获取最后一次生成 RDB 的 时间，对应 info 统计的 rdb_last_save_time 选项。</li><li>进程发送信号给父进程表示完成，父进程更新统计信息，具体见 info Persistence下的 rdb_* 相关选项。</li></ul><p>AOF持久化</p><blockquote><p>增量持久化</p></blockquote><p><img src="../../img/image/redis/AOF.png" alt="AOF.png"></p><ol><li>所有的写入命令会追加到aof_buf(缓冲区)中。</li><li>AOF缓冲区根据对应的策略向硬盘做同步操作。</li><li>随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的。</li><li>当Redis服务器重启时，可以加载AOF文件进行数据恢复。</li></ol><h4 id="容灾方案拓扑"><a href="#容灾方案拓扑" class="headerlink" title="容灾方案拓扑"></a>容灾方案拓扑</h4><p>整体的数据一致性架构，可见数据层要做实时备份需要大量的资源。<br><img src="https://yycreate.github.io/img/image/redis/whole.png" alt="img.png"></p><p>redis中间件集群架构<br>主要场景：</p><blockquote><p>扩容/缩容: 集群模式部署<br><img src="https://yycreate.github.io/img/image/redis/kuo_suo.png" alt="img.png"></p><p>切换</p><p>数据迁移/快速迁移数据/减少迁移时影响面</p></blockquote><hr><h4 id="压测方案"><a href="#压测方案" class="headerlink" title="压测方案"></a>压测方案</h4><h5 id="1-目标"><a href="#1-目标" class="headerlink" title="1.目标"></a>1.目标</h5><h5 id="2-资源选择，部署方案"><a href="#2-资源选择，部署方案" class="headerlink" title="2.资源选择，部署方案"></a>2.资源选择，部署方案</h5><h5 id="3-实际压测结果"><a href="#3-实际压测结果" class="headerlink" title="3.实际压测结果"></a>3.实际压测结果</h5><h4 id="容灾方案-1"><a href="#容灾方案-1" class="headerlink" title="容灾方案"></a>容灾方案</h4><ol><li><p>集群架构部署及容灾</p></li><li><p>哨兵结构容灾方案</p></li></ol><h3 id="五-数据迁移与备份"><a href="#五-数据迁移与备份" class="headerlink" title="五.数据迁移与备份"></a>五.数据迁移与备份</h3><p>// todo</p><h3 id="六-版本特性"><a href="#六-版本特性" class="headerlink" title="六.版本特性"></a>六.版本特性</h3><p>// todo</p><hr><div align="center"><font color = orange>你的支持是我加班的动力</font><br/><strong>微信</strong><br/><img src="https://yycreate.github.io/img/wxzf.jpg" style="width:256px;"/><strong>支付宝</strong><br/><img src="https://yycreate.github.io/img/zfbzf_1.jpg" style="width:256px;"/></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>redis的使用</title>
      <link href="/redis-redis-point/"/>
      <url>/redis-redis-point/</url>
      
        <content type="html"><![CDATA[<p>该篇不会写redis的基础使用，而是根据redis的特性去挖掘一下原理，并深入理解</p><h3 id="redis-淘汰策略"><a href="#redis-淘汰策略" class="headerlink" title="redis 淘汰策略"></a>redis 淘汰策略</h3><h3 id="redis-内存访问流程"><a href="#redis-内存访问流程" class="headerlink" title="redis 内存访问流程"></a>redis 内存访问流程</h3><p><a href="https://www.jianshu.com/p/2ce36bca2869" target="_blank" rel="noopener">https://www.jianshu.com/p/2ce36bca2869</a></p><h3 id="redis-数据同步流程"><a href="#redis-数据同步流程" class="headerlink" title="redis 数据同步流程"></a>redis 数据同步流程</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>redis 业务实现方案</title>
      <link href="/redis-redis-business/"/>
      <url>/redis-redis-business/</url>
      
        <content type="html"><![CDATA[<h5 id="业务有序消费方案"><a href="#业务有序消费方案" class="headerlink" title="业务有序消费方案"></a>业务有序消费方案</h5><p><img src="../../img/image/redis/redis_zk.png" alt="redis_zk.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>DDD领域模型</title>
      <link href="/server-DDD-area/"/>
      <url>/server-DDD-area/</url>
      
        <content type="html"><![CDATA[<p>注： 这是很抽象的概念，尽量举例，让概念更好理解。</p><h3 id="1-聚合根，聚合"><a href="#1-聚合根，聚合" class="headerlink" title="1. 聚合根，聚合"></a>1. 聚合根，聚合</h3><blockquote><p>定义：聚合是用来定义领域所有权和边界的。</p></blockquote><h4 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h4><blockquote><p>定义：<br>一个由它的标识定义的对象叫做实体；<br>具有唯一标识性和可变性；<br>它是具有业务逻辑；<br>对应现实世界一个具体的业务对象。</p></blockquote><p>简而言之，就是把多个相关的值与对象整体堪称一个域，简化整体的关系。</p><h3 id="2-领域，子域"><a href="#2-领域，子域" class="headerlink" title="2. 领域，子域"></a>2. 领域，子域</h3><blockquote><p>领域即问题域，通常是根据一个组织所处的行业进行识别，<br>它基于业务的愿景，定义了系统要解决的现实问题的目标和范围。<br>领域越大，业务的范围也越大，大的领域可以拆分成小的问题域，称之为子域。<br>根据子域重要性和功能属性划，可以将其分为三类：核心域、支撑域和通用域</p></blockquote><p>简单来说，对于产品可以把领域理解为这个产品所解决的问题。</p><ul><li>例如抖音，为了就是输出内容，商户打广告等等平台，且想留存用户在抖音内消费等等功能的产品<ul><li>核心<ol><li>需要优质的内容输出机制，吸引用户创作</li><li>需要吸引用户留存，提高用户体验</li><li>让商家看到抖音的用户潜力，吸引商家入驻在这投放广告，让用户创作更好的优质内容。</li></ol></li></ul></li><li>例如微信，让腾讯内的产品切入到生活的方方面面<ul><li>核心<ul><li>优质的社交用户体系体验，留存了很多用户（微信好友，通信功能）</li></ul></li><li>支撑域<ul><li>微信的用户生态-腾讯其他产品的支撑域名</li><li>朋友圈，微信支付，微信好友</li></ul></li><li>通用域<ul><li>公众号，订阅号消息，短信等等</li></ul></li></ul></li><li>例如懂车帝，可能上面的体系太大不太清楚其中的关系；懂车帝主要解决选车的问题<ul><li>核心<ul><li>车型信息（类型，价格，性能参数）</li></ul></li><li>支撑（使用户在这里作出抉择，用户留存）<ul><li>车辆对比（里程，价格，品牌，容量等等）</li><li>用户测评</li><li>新品发布</li><li>各地补贴消息</li><li>车友圈</li></ul></li><li>通用<ul><li>支持服务…</li><li>脏词子域</li><li>日志子域</li><li>监控子域</li><li>ip子域</li></ul></li></ul></li></ul><h3 id="限界上下文"><a href="#限界上下文" class="headerlink" title="限界上下文"></a>限界上下文</h3><p>将整个环节的主要部分划分开来。</p><p>电商场景下的购买：</p><ul><li>一致性事务边界<ul><li>边界不清会导致，整体的事务重，会影响并发或者扩容资源浪费等等问题</li><li>边界划分很大的时候，状态很难捕捉。（想一想，购物车，下单，支付，物流等等都在边界内，是很难确认流程重存在的问题）</li><li>保持域内的事务一致性，能更好管理整体流程的完整</li><li>领域事件，通过捕捉某个领域的事件或者异常，通过消息队列给到别的领域去消费</li></ul></li></ul><h3 id="领域划分几个步骤"><a href="#领域划分几个步骤" class="headerlink" title="领域划分几个步骤"></a>领域划分几个步骤</h3><ol><li>定义所有实体（值）</li><li>关联所有实体的关系，并用虚线连线</li><li>删除实体键多对多的关系，若存在这种关系划分为独立域。</li><li>单个存在无意义的实体，用实线连接他们的关联关系</li><li>删除剩下的虚线，就得到了划分好的领域</li></ol><p>以下是推演：</p><p><img src="img.png" alt="img.png"></p><p>// todo</p><hr><div align="center"><font color = orange>你的支持是我加班的动力</font><br/><strong>微信</strong><br/><img src="https://yycreate.github.io/img/wxzf.jpg" style="width:256px;"/><strong>支付宝</strong><br/><img src="https://yycreate.github.io/img/zfbzf_1.jpg" style="width:256px;"/></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>高并发架构设计经验</title>
      <link href="/server-availablity/"/>
      <url>/server-availablity/</url>
      
        <content type="html"><![CDATA[<h3 id="一、高并发使用场景以及业务背景"><a href="#一、高并发使用场景以及业务背景" class="headerlink" title="一、高并发使用场景以及业务背景"></a>一、高并发使用场景以及业务背景</h3><p>高并发解决的核心问题是在同一时间上有大量的请求过来，然后我们的系统要怎么抗住这些请求带来的压力。比如在线直播服务，同时有上百万甚至上千万人观看。比如秒杀品，同时有大量用户涌入。<br>高并发是从业务角度去描述系统的能力，实现高并发的手段可以采用分布式，也可以采用缓存等，当然也包括多线程、协程，但远远不仅如此；高并发的基本表现为单位时间内系统能够同时处理的请求数，高并发的核心是对资源的有效压榨，有限的资源应对大量的请求。<br>现代互联网服务，基本上都要考虑高并发问题，因为一般的产品，用户的请求量都很大。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="二、高并发架构设计经验"><a href="#二、高并发架构设计经验" class="headerlink" title="二、高并发架构设计经验"></a>二、高并发架构设计经验</h3><p>高并发架构设计，可以从三大层来建设和分析</p><ul><li>基础设施层：这个是最基础的依赖，主要是一些服务的部署。<ul><li>强大的laas平台，可以跟业务隔离，基础平台提供问的服务，让开发设计更集中在业务中。</li><li>持久层平台，缓存平台，消息处理平台等等技术</li></ul></li><li>服务端架构层：可以粗浅地理解为业务代码，支持业务代码的各种服务。主要包括各种架构和模块的设计。<ul><li>业务域</li><li>支撑域</li><li>核心域</li><li>调用架构</li><li>拓展架构</li></ul></li><li>服务应用层： 这个主要是针对我们写的代码来进行优化改进，以及代码架构兼容运维架构，等等更多的工具开发。<ul><li>devops架构</li><li>运维架构，运维工具</li><li>代码开发架构</li><li>扩容，缩容，容灾架构</li><li>安全架构</li></ul></li></ul><h4 id="2-1、基础设施层"><a href="#2-1、基础设施层" class="headerlink" title="2-1、基础设施层"></a>2-1、基础设施层</h4><p>部署：多 IDC + 异地多活<br>基础设施层一般包含了服务器、IDC、部署方式等等。目前而言，我们一般都用容器部署的方式，而容器的底层能力基本也都是建立在 k8s 容器层之上的，服务本身的部署管理已经有成熟的设施帮我们实现了。具体到部署方式，包括但不限于：<br>多IDC机房部署。比如服务同时在粤西、东北两地部署。 这个依赖我们的服务是无状态的</p><blockquote><p>PS:异地多活架构等相关部署需要了解方案</p></blockquote><p>监控：可观测性<br>系统的可观测性主要包含三个部分: logging、tracing、metrics。<br>这个一般都要引入可观测系统，在异常中快速定位问题。（监控平台需要另外的团队去支持）</p><h4 id="2-2、服务端架构层"><a href="#2-2、服务端架构层" class="headerlink" title="2-2、服务端架构层"></a>2-2、服务端架构层</h4><p>个人观点，要基于业务的特性，要保持可扩展，稳定高可用，兼容各类服务的特点。</p><ul><li>稳定性服务。保证一致性，性能放缓也可。</li><li>高可用服务。消息吞吐，保证可用性高并发。</li><li>支持调度服务，高可用，高吞吐。</li></ul><p>具体分析：支付系统，日志系统。</p><h5 id="系统分层设计：分层、分割、分布式"><a href="#系统分层设计：分层、分割、分布式" class="headerlink" title="系统分层设计：分层、分割、分布式"></a>系统分层设计：分层、分割、分布式</h5><ul><li><p>架构分层<br>将系统在横向维度上切分成几个部分，每一层的功能职责要足够单一，然后通过上层对下层的依赖和调度组成一个完整的系统<br>比如把电商系统分成：应用层，服务层，数据层。(具体分多少个层次根据自己的业务场景)<br>应用层：网站首页，用户中心，商品中心，购物车，红包业务，活动中心等，负责具体业务和视图展示<br>服务层：订单服务，用户管理服务，红包服务，商品服务等，为应用层提供服务支持<br>数据层：关系数据库，nosql数据库 等，提供数据存储查询服务</p></li><li><p>业务分割<br>在纵向方面对业务进行切分，将一块相对复杂的业务分割成不同的模块单元，对应的是模块的划分，通过合理的模块划分，使得每个模块都能可以满足 高内聚低耦合 的设计要求，这样不同的模块可以分布式部署，也能提高并发处理能力和功能扩展<br>比如用户中心可以分割成：账户信息模块，订单列表模块，充值模块，优惠券模块等</p></li><li><p>分布式<br>分布式应用和服务,将分层或者分割后的业务分布式部署，独立的应用服务器，数据库，缓存服务器，当业务达到一定用户量的时候，再进行服务器均衡负载，数据库，缓存主从集群</p></li></ul><h5 id="集群架构设计：应用集群、数据集群"><a href="#集群架构设计：应用集群、数据集群" class="headerlink" title="集群架构设计：应用集群、数据集群"></a>集群架构设计：应用集群、数据集群</h5><p>应对高并发系统，不管是应用层面还是数据层面，单机都不可能搞定，因此都需要搭建集群架构，然后通过负载均衡来对外提供服务。同时集群架构还能保证系统的可用性，当某台服务或者机器异常，负载均衡会自动剔除，不会影响对外服务。<br>应用服务器集群。将业务层，接入层，应用层，数据层（持久层）分开部署，完全隔离，提供相应的接口相互访问。不同层级根据需求进行动态扩容或者拆分等等。</p><h5 id="数据读写分离"><a href="#数据读写分离" class="headerlink" title="数据读写分离"></a>数据读写分离</h5><p>数据库设计：读写分离+分库分表+冷热分离<br>应对高并发，数据的存储，首先就要做好预估，先进行分库分表 和 读写分离，最后可以根据情况来看是否冷热分离：</p><ul><li>读写分离。互联网系统大多数都是读多写少，因此读写分离可以帮助主库抗量。一般我们都是一主多从的架构，可以抗量，也可以保证数据不丢。分库分表只能解决 QPS 高，但是无法解决 TPS 高，比如写入的量足够大的话（TPS 高），就得分库分表。</li><li>分库分表。数据存储量大的时候，就需要通过分库分表来存储。先分，避免后期要拆，后期拆的话，就面临洗数据的问题，就需要采用双写模式来搞定。<br>分库分表模式虽然能显著提升数据库的容量，但会增加系统复杂性，而且由于只能支持少数的几个维度读写，从某种意义上来说对业务系统也是一种限制，因此在设计分库分表方案的时候需要结合具体业务场景，更全面的考虑。</li><li>冷热分离。针对业务场景而言，如果数据有冷热之分的话，可以将历史冷数据与当前热数据分开存储，这样可以减轻当前热数据的存储量，可以提高性能。</li></ul><p>不过，既然是高并发系统，不能应用层直接读写 DB 的，一定有一个缓存在上面，如果直接读写 DB 能够搞定，其实不能叫高并发了，只能说是并发有点高。在非互联网系统里面还是可以的。</p><h5 id="缓存设计：多级缓存架构和本地缓存"><a href="#缓存设计：多级缓存架构和本地缓存" class="headerlink" title="缓存设计：多级缓存架构和本地缓存"></a>缓存设计：多级缓存架构和本地缓存</h5><p>缓存的最大作用是可以提升系统性能，保护后端存储不被大流量打垮，增加系统的伸缩性。缓存的设计，需要分多个思路并行<br>首先要考虑的，就是必须在数据库之上，增加一层分布式缓存，比如 Redis 或者 Memcached。<br>这里需要考虑一下缓存和数据库一致性的问题。<br>其次需要考虑的是多级缓存架构。分几级缓存设计，同时设计热点缓存架构。<br>在分布式缓存之上，还可以加一个本地缓存，来缓存最热的数据<br>采用多个分布式缓存来搭建多级缓存。</p><p>// todo 架构设计</p><h5 id="消息队列设计：MQ-抗量和削峰"><a href="#消息队列设计：MQ-抗量和削峰" class="headerlink" title="消息队列设计：MQ 抗量和削峰"></a>消息队列设计：MQ 抗量和削峰</h5><p>针对流量突峰，仅仅有缓存来抗量可能还不够，还需要使用消息队列来削峰。使用消息队列后，可以将同步处理的请求改为 通过消费 MQ 消息来异步消费，这样可以大大减少系统处理的压力，增加系统的并发量。常用的消息队列比如 kafka。</p><h5 id="服务治理设计：超时、熔断、降级、限流等"><a href="#服务治理设计：超时、熔断、降级、限流等" class="headerlink" title="服务治理设计：超时、熔断、降级、限流等"></a>服务治理设计：超时、熔断、降级、限流等</h5><p>超时、熔断、降级、限流等都是常规策略。<br>服务端框架的网关实现</p><ul><li>超时策略 </li><li>熔断策略 </li><li>降级策略 </li><li>限流策略</li></ul><h5 id="资源隔离设计：-ZOOM-部署"><a href="#资源隔离设计：-ZOOM-部署" class="headerlink" title="资源隔离设计： ZOOM 部署"></a>资源隔离设计： ZOOM 部署</h5><p>资源隔离有各种类型，物理层面的服务器资源、中间件资源，代码层面的线程池、连接池，这些都可以做隔离。<br>一般我们最常见的就是应用部署层面的，比如ZOOM区域化部署。</p><ul><li>一个服务对外的使用方可能有 A 业务、B 业务，那么如何保证 AB 业务不会相互影响，那么就是 ZOOM 化部署。 ZOOM区域部署也可以防止非关键业务来影响关键核心业务。</li><li>一个隔离的维度可以是按业务场景区分，分为关键集群、次关键集群和非关键集群三类，这样能避免关键和非关键业务互相影响。</li></ul><p>关于ZOOM区域的具体例子：</p><ul><li>微信红包用户发一个红包时，微信红包系统生成一个ID作为这个红包的唯一标识。接下来这个红包的所有发红包、抢红包、拆红包、查询红包详情等操作，都根据这个ID关联。红包系统根据这个红包ID，按一定的规则（如按ID尾号取模等），垂直上下切分。</li><li>切分后，一个垂直链条上的逻辑Server服务器、DB统称为一个ZOOM。</li><li>各个ZOOM之间相互独立，互相解耦。并且同一个红包ID的所有请求，包括发红包、抢红包、拆红包、查详情详情等，垂直stick到同一个ZOOM内处理，高度内聚。</li><li>通过这样的方式，系统将所有红包请求这个巨大的洪流分散为多股小流，互不影响，分而治之，</li></ul><blockquote><p>区域化，鉴于业务上的考虑以及对业务的兼容度评估</p></blockquote><h4 id="2-3、服务应用层"><a href="#2-3、服务应用层" class="headerlink" title="2-3、服务应用层"></a>2-3、服务应用层</h4><ul><li><p>多线程、线程同步、协程<br>并发问题一直是服务端编程中的重点和难点问题，为了优化系统的并发量，单机解决高并发问题从最初的 Fork 进程开始，到进程池/线程池，再到 Epoll 事件驱动(Nginx)，再到协程（如 Goroutine）。<br>对于 Go 语言，尽可能的多使用协程去提高并发能力。</p></li><li><p>异步化<br>消息队列也是一种异步化操作，但是除了依赖外部的中间件如消息队列，在应用内我们也可以通过线程池、协程的方式做异步化，能异步的尽量异步处理，这样可以提高并发。</p></li><li><p>预处理：预加载、预热<br>系统的预热一般有JVM预热、缓存预热、DB预热等，通过预热的方式让系统先“热”起来，为高并发流量的到来做好准备。 </p></li><li>比如在电商的大促到来前，我们可以把一些热点的商品提前加载到缓存中，防止大流量冲击DB。</li></ul><p>Redis MS架构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="前端业务设计"><a href="#前端业务设计" class="headerlink" title="前端业务设计"></a>前端业务设计</h3><p>还有一种预热的思路是利用业务的特性做一些预加载，</p><ul><li>feeds 流刷新的时候，提前加载 1-2 页数据，使用户端感觉不到加载卡顿，提高用户体验。</li></ul><hr><div align="center"><font color = orange>你的支持是我加班的动力</font><br/><strong>微信</strong><br/><img src="https://yycreate.github.io/img/wxzf.jpg" style="width:256px;"/><strong>支付宝</strong><br/><img src="https://yycreate.github.io/img/zfbzf_1.jpg" style="width:256px;"/></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>nosql-mongo</title>
      <link href="/nosql-mongo/"/>
      <url>/nosql-mongo/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="title-mongodb"><a href="#title-mongodb" class="headerlink" title="title: mongodb"></a>title: mongodb</h2><h3 id="1-NO-SCHEMA"><a href="#1-NO-SCHEMA" class="headerlink" title="1.NO SCHEMA"></a>1.NO SCHEMA</h3><blockquote><p>mongodb是文档型数据库，文档结构是BSON（binary serialized document format）的类JSON二进制存储格式。</p><p>支持添加字段，还支持date和BinData数据类型，给予NO SCHEMA和SCHEMA FREE的特性。</p></blockquote><h3 id="2-mongodb复制集群"><a href="#2-mongodb复制集群" class="headerlink" title="2.mongodb复制集群"></a>2.mongodb复制集群</h3><p>复制集群保证mongodb数据的高可用。将数据复制到多台机器上，避免单点故障。</p><blockquote><p>复制集群的角色：</p><ol><li>有且仅有一个主节点（Primary）:集群的写操作入口，主节点挂掉会重新选取一个主节点。</li><li>一个或者多个从节点（Secondary）:一般2个或以上，从主节点同步数据，主节点挂掉可被选举为主节点。</li><li>零个或者一个仲裁节点（Arbiter）:为了节约资源或多机房容灾用，负责主节点的选举时投票，不存数据（保证节点多票通过选举）。 </li></ol><p>三节点复制集群一般使用PSS或者PSA结构。</p></blockquote><p>复制集群保持数据一致性的设计：</p><p>Journal日志：</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>红锁，redis主从部署的分布式锁</title>
      <link href="/redis-red-lock/"/>
      <url>/redis-red-lock/</url>
      
        <content type="html"><![CDATA[<blockquote><p>红锁采用主节点过半机制，即获取锁或者释放锁成功的标志为：在过半的节点上操作成功。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>protocol-tcp</title>
      <link href="/protocol-tcp/"/>
      <url>/protocol-tcp/</url>
      
        <content type="html"><![CDATA[<ul><li>tcp 黏包/沾包</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql 优化方案</title>
      <link href="/mysql-transition-level/"/>
      <url>/mysql-transition-level/</url>
      
        <content type="html"><![CDATA[<h3 id="1-索引优化"><a href="#1-索引优化" class="headerlink" title="1.索引优化"></a>1.索引优化</h3><h4 id="索引大小优化"><a href="#索引大小优化" class="headerlink" title="索引大小优化"></a>索引大小优化</h4><h4 id="避免索引失效"><a href="#避免索引失效" class="headerlink" title="避免索引失效"></a>避免索引失效</h4><h4 id="联合索引，减少回表"><a href="#联合索引，减少回表" class="headerlink" title="联合索引，减少回表"></a>联合索引，减少回表</h4><h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><h4 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h4><h3 id="2-单机优化"><a href="#2-单机优化" class="headerlink" title="2.单机优化"></a>2.单机优化</h3><h3 id="3-业务优化"><a href="#3-业务优化" class="headerlink" title="3. 业务优化"></a>3. 业务优化</h3><h4 id="避免连表查询join"><a href="#避免连表查询join" class="headerlink" title="避免连表查询join"></a>避免连表查询join</h4><h4 id="拆表，热点字段放在主表"><a href="#拆表，热点字段放在主表" class="headerlink" title="拆表，热点字段放在主表"></a>拆表，热点字段放在主表</h4><h3 id="4-主从部署优化"><a href="#4-主从部署优化" class="headerlink" title="4.主从部署优化"></a>4.主从部署优化</h3><h3 id="5-分库分表优化"><a href="#5-分库分表优化" class="headerlink" title="5.分库分表优化"></a>5.分库分表优化</h3><h3 id="6-多地容灾部署优化"><a href="#6-多地容灾部署优化" class="headerlink" title="6.多地容灾部署优化"></a>6.多地容灾部署优化</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql 执行计划</title>
      <link href="/mysql-mysql-explain-plan/"/>
      <url>/mysql-mysql-explain-plan/</url>
      
        <content type="html"><![CDATA[<h3 id="执行语句语法"><a href="#执行语句语法" class="headerlink" title="执行语句语法"></a>执行语句语法</h3><p>EXPLAIN/DESC SQL语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span></span><br></pre></td></tr></table></figure><h3 id="执行计划参数详解"><a href="#执行计划参数详解" class="headerlink" title="执行计划参数详解"></a>执行计划参数详解</h3><h4 id="1-执行计划参数"><a href="#1-执行计划参数" class="headerlink" title="1.执行计划参数"></a>1.执行计划参数</h4><font  color=#329999>select_type查询类型</font>- SIMPLE：简单查询- PRIMARY：复杂查询中最外层的 select- SUBQUERY：包含在 select 中的子查询（不在 from 子句中）- DERIVED：包含在 from 子句中的子查询（会将结果存放在一个临时表中，也称为派生表）- UNION：第二个select中查询UNION,则被标记为UNION，如果UNION出现在from子查询中，最外层被标记为DERIVED- UNION RESULT：从UNION表获取结果的select<font  color=#329999>type-访问类型</font><blockquote><p>type代表访问类型，是判断sql执行性能比较关键的一个字段，性能从高到低依次是：</p><p>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p></blockquote><ul><li>system：表示只有一条数据，类似于系统表，是const的一种特例</li><li>const：表示通过索引一次就查询到数据，比较块，用于primary key（主键）和unique唯一索引</li><li>eq_ref：用于“=”运算符比较的索引列</li><li>ref：非唯一索引扫描</li><li>rang：检索给的范围的值，使用一个索引进行选择，where后面使用between、&gt;、&lt;、in等</li><li>index：当前查询的结果全部为索引列，虽然也是全部扫描，但是只查询索引数据，没有之间查询数据</li><li>all：遍历全部查询</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL事务以及实现</title>
      <link href="/mysql-mysql-transition/"/>
      <url>/mysql-mysql-transition/</url>
      
        <content type="html"><![CDATA[<h3 id="事务等级"><a href="#事务等级" class="headerlink" title="事务等级"></a>事务等级</h3><h4 id="1-读取未提交-RU"><a href="#1-读取未提交-RU" class="headerlink" title="1.读取未提交(RU)"></a>1.读取未提交(RU)</h4><blockquote><p>所有事务可以读到其他未提交事务的执行结果。</p></blockquote><p>缺点：</p><ul><li>性能没有很大提高</li><li>某事物把未提交的数据读取，为脏读（Dirty Read）。</li></ul><h4 id="2-读取已提交-RC"><a href="#2-读取已提交-RC" class="headerlink" title="2.读取已提交(RC)"></a>2.读取已提交(RC)</h4><blockquote><p>一个事务只能看见已经提交事务所做的改变。</p></blockquote><p>缺点：</p><ul><li>当某个事务执行时，多次查询，会查询到不一样的结果。（不可重复读，重复读同一条数据结果可能不一致）<br>简而言之:别的事务可能提交了新数据，导致同一个SQL读两次会有不一样的数据</li></ul><h4 id="3-可重复读（默认事务隔离级别）-RR"><a href="#3-可重复读（默认事务隔离级别）-RR" class="headerlink" title="3.可重复读（默认事务隔离级别）(RR)"></a>3.可重复读（默认事务隔离级别）(RR)</h4><blockquote><p>确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。</p></blockquote><p>缺点：</p><ul><li>在同一个事务中范围查询，别的事务在该范围间添加/删除/修改数据，会导致该事务中多次读取结果不一致，称之为幻读（Phantom Read）。</li></ul><p>解决方案：</p><ul><li>mvcc</li><li>间隙锁</li></ul><h5 id="mvcc实现"><a href="#mvcc实现" class="headerlink" title="mvcc实现"></a>mvcc实现</h5><blockquote><p>MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理读写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读。</p></blockquote><font color=#329999>当前读：读取最新版本数据</font><p>使用场景</p><ul><li>1.使用共享锁 select lock in share mode;</li><li>2.使用排他锁 select … for update;update;insert;delete;</li></ul><font color=#329999>快照读：读取历史版本数据</font><p>使用场景</p><ul><li>不加锁的select读，非阻塞读。</li></ul><font color=#329999>MVCC实现</font><p>前提是，事务级别不是串行。基于并发控制考虑，快照读的实现是基于多版本并发控制，即MVCC,可以认为MVCC是行锁的。避免枷锁，降低开销；</p><blockquote><p>MVCC模块在MySQL中的具体实现是由三个隐式字段，undo日志、read view三个组件来实现的。</p></blockquote><p>隐式字段：</p><ul><li>DB_TRX_ID 事务号：记录创建这条记录，最后一次修改该记录事务的ID。每处理一个事务，其值自动 +1。</li><li>DB_ROLL_PTR 回滚指针：指向这条记录的上一个版本 (存储于rollback segment回滚段里)，通过这个指针才能查找之前版本的数据。</li><li>DB_ROW_ID 隐含ID：如果数据库没有设置主键，那么InnoDB会以DB_ROW_ID 产生一个聚簇索引</li><li>创建和删除版本号：记录当前数据创建和删除的版本</li></ul><p>read view全局属性：<br>首先要知道Read View中的三个全局属性：</p><ul><li>trx_list:   一个数值列表，用来维护Read View生成时刻系统正活跃的事务id (1,2,3)</li><li>up_limit_id:  记录trx_list列表中事务最小的id（1）</li><li>low_limit_id： Read View生成时刻系统尚未分配的下一个事务id（4）</li></ul><p><font color=#329999>MVCC判断顺序</font><br>判断是不符合执行下一个，符合条件读取read view数据。</p><ol><li>DB_TRX_ID &lt;  up_limit_id（事务列表中最小的id），表示别的事务可能修改数据，读取read view数据。</li><li>DB_TRX_ID &gt;= low_limit_id（未分配事务id），这该事务会读取别的事务的read view。</li><li>DB_TRX_ID是否活跃在事务中，若果在事务中，已生成read view修改事务当前事务看不见。</li></ol><h5 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h5><p>加锁的基本单位为next-key lock。<br>当<code>范围查询具体条件不是相等条件检索数据</code>，<code>并请求共享锁或排他锁</code>时，innoDB会给符合条件的已有数据记录索引项加锁。</p><p><img src="https://yycreate.github.io/img/mysql/next-key-lock.png" alt="next-key-lock.png"><br>next-key-lock锁的区间为前开后闭区间。</p><blockquote><p>共享锁（读锁/S锁）：多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改</p><p>触发条件：</p><p>排他锁（写锁/X锁）：不能与其他所并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据就行读取和修改。</p><p>触发条件：</p></blockquote><p>锁的粒度为id=1</p><p>添加<code>for update</code>关键字，使用排他锁，等该事务完成之后，才能对id=1这行数据进行读写（获取共享锁或者排他锁）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where id &#x3D; 1 for update;</span><br></pre></td></tr></table></figure></p><p>共享查<code>lock in share mode</code>，获取共享锁。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where id &#x3D; 1 lock in share mode;</span><br></pre></td></tr></table></figure></p><p>不使用锁，不管是否使用排他锁或者共享锁，都能查询结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where id &#x3D; 1</span><br></pre></td></tr></table></figure></p><p>间隙锁的触发条件:</p><blockquote><p>范围查询并且查询未命中记录，查询条件必须命中索引、间隙锁只会出现在REPEATABLE_READ（重复读)的事务级别中。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user_info where id &gt; 1 and id &lt; 4 for update</span><br></pre></td></tr></table></figure><h5 id="状态锁"><a href="#状态锁" class="headerlink" title="状态锁"></a>状态锁</h5><p>状态锁包括意向共享锁和意向排它锁，把他们区分为状态锁的一个核心逻辑，是因为这两个锁都是都是描述是否可以对某一个表进行加表锁的状态。</p><ol><li>当一个事务试图对整个表进行加锁（共享锁或排它锁）之前，首先需要获得对应类型的意向锁（意向共享锁或意向共享锁）</li><li>当一个事务试图对整个表进行加共享锁之前，首先需要获得这个表的意向共享锁。</li><li>当一个事务试图对整个表进行加排它锁之前，首先需要获得这个表的意向排它锁。</li></ol><p>为什么要意向锁：</p><ol><li>innodb加锁的方式是基于索引，并且加锁粒度是行锁。</li><li>事务A对整表进行修改，需要判断是否表内的某一行有锁</li><li>需要遍历整个索引才能判断是否有锁，太浪费性能了。添加意向锁的状态，表示该表的某行是否有锁在使用。</li></ol><h4 id="4-串行化-SC"><a href="#4-串行化-SC" class="headerlink" title="4.串行化(SC)"></a>4.串行化(SC)</h4><blockquote><p>所有事务按照次序依次执行，最高的安全性</p></blockquote><p>缺点：</p><ul><li>效率会大大下降，应用程序的性能会急剧降低</li></ul><h3 id="核心日志"><a href="#核心日志" class="headerlink" title="核心日志"></a>核心日志</h3><h4 id="1-bin-log"><a href="#1-bin-log" class="headerlink" title="1.bin-log"></a>1.bin-log</h4><p>记录执行的数据，记录的是数据的逻辑日志，例如执行力什么更新语句等等，有STATEMENT或者SQL形式。</p><p><img src="binlog.png" alt="binlog.png"></p><p>fsync刷盘时机：<br>redo log 为了提高性能也使用了缓存redo log buffer ，可以通过 innodb_flush_log_at_trx_commit 来配置刷盘策略，默认 = 1 ，不会丢数据。除了事务提交时刷盘，InnoDB存储引擎还有一个后台线程，每隔1秒，执行一次 write + fsync 刷盘。</p><ul><li>0 ：每次事务提交时不进行刷盘操作，mysql挂了会丢失1秒数据</li><li>1 ：每次事务提交时都将进行刷盘操作 write + fsync，不会丢数据</li><li>2 ：每次事务提交时只执行write，mysql挂了不会丢数据，服务器挂了会丢失1秒数据</li></ul><p>根据my.cnf配置设置开启binlog<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 开启binlog 存放位置</span></span><br><span class="line">log-bin = mysql-bin</span><br><span class="line"><span class="meta">#</span><span class="bash"> 最大的大小</span></span><br><span class="line">max_binlog_size = 1G</span><br><span class="line"><span class="meta">#</span><span class="bash"> binlog的刷盘时机</span></span><br><span class="line">sync-binlog = 1</span><br></pre></td></tr></table></figure></p><h4 id="2-undo-log"><a href="#2-undo-log" class="headerlink" title="2.undo-log"></a>2.undo-log</h4><p>回滚日志，根据binlog的执行日志，生成一条可以返回原本数据版本的记录</p><h4 id="3-redo-log"><a href="#3-redo-log" class="headerlink" title="3.redo-log"></a>3.redo-log</h4><p>redo日志是根据原有的数据版本生成的一份数据备份，属于物理数据。<br>重做日志：保证数据的一致性。</p><p>重做日志的数据保存流程：<br><img src="redo_log.png" alt="redo_log.png"></p><hr><div align="center"><font color = orange>你的支持是我加班的动力</font><br/><strong>微信</strong><br/><img src="https://yycreate.github.io/img/wxzf.jpg" style="width:256px;"/><strong>支付宝</strong><br/><img src="https://yycreate.github.io/img/zfbzf_1.jpg" style="width:256px;"/></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL语句是如何执行的</title>
      <link href="/mysql-myql-excel-sql/"/>
      <url>/mysql-myql-excel-sql/</url>
      
        <content type="html"><![CDATA[<h3 id="mysql-结构"><a href="#mysql-结构" class="headerlink" title="mysql 结构"></a>mysql 结构</h3><h3 id="执行excel的流程"><a href="#执行excel的流程" class="headerlink" title="执行excel的流程"></a>执行excel的流程</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>kafka</title>
      <link href="/mq-kafka/"/>
      <url>/mq-kafka/</url>
      
        <content type="html"><![CDATA[<h3 id="kafka逻辑架构"><a href="#kafka逻辑架构" class="headerlink" title="kafka逻辑架构"></a>kafka逻辑架构</h3><p><img src="kafka_cluster.png" alt="kafka_cluster.png"></p><ul><li>Producer：Producer即生产者，消息的产生者，是消息的入口。</li><li>Broker：Broker是kafka实例，每个服务器上有一个或多个kafka的实例，我们姑且认为每个broker对应一台服务器。每个kafka集群内的broker都有一个不重复的编号，如图中的broker-0、broker-1等……</li><li>Topic：消息的主题，可以理解为消息的分类，kafka的数据就保存在topic。在每个broker上都可以创建多个topic。</li><li>Partition：Topic的分区，每个topic可以有多个分区，分区的作用是做负载，提高kafka的吞吐量。同一个topic在不同的分区的数据是不重复的，partition的表现形式就是一个一个的文件夹！</li><li>Replication:每一个分区都有多个副本，副本的作用是做备胎。当主分区（Leader）故障的时候会选择一个备胎（Follower）上位，成为Leader。在kafka中默认副本的最大数量是10个，且副本的数量不能大于Broker的数量，follower和leader绝对是在不同的机器，同一机器对同一个分区也只可能存放一个副本（包括自己）。</li><li>Message：每一条发送的消息主体。</li><li>Consumer：消费者，即消息的消费方，是消息的出口。</li><li>Consumer Group：我们可以将多个消费组组成一个消费者组，在kafka的设计中同一个分区的数据只能被消费者组中的某一个消费者消费。同一个消费者组的消费者可以消费同一个topic的不同分区的数据，这也是为了提高kafka的吞吐量！</li><li>Zookeeper：kafka集群依赖zookeeper来保存集群的的元信息，来保证系统的可用性。</li></ul><h3 id="kafka消息获取模式"><a href="#kafka消息获取模式" class="headerlink" title="kafka消息获取模式"></a>kafka消息获取模式</h3><h4 id="1-生产者Producer"><a href="#1-生产者Producer" class="headerlink" title="1.生产者Producer"></a>1.生产者Producer</h4><p>pull（拉模式），集群记录producer的信息，producer要事先注册，注册信息记录仔zookeeper中，后续版本会与zookeeper解耦。</p><p>push（推模式）， 生产者有数据就塞给消息队列，不用管其他的事情。</p><blockquote><p>一致性比较强的，以及有序消费的使用pull，如订单，消费记录等等；吞吐量要求比较大，数据允许丢失使用push，如短信，埋点等等</p></blockquote><h3 id="消息堆积"><a href="#消息堆积" class="headerlink" title="消息堆积"></a>消息堆积</h3><h3 id="有序消费实现方案"><a href="#有序消费实现方案" class="headerlink" title="有序消费实现方案"></a>有序消费实现方案</h3><h4 id="1-消费堆积"><a href="#1-消费堆积" class="headerlink" title="1.消费堆积"></a>1.消费堆积</h4><blockquote><p>实现：消费者判断消息是否达到消费时间，未达到消费之间重新堆积到原队列列尾，达到延时要求就消费。</p><p>缺点：当消息批量堆积的时候，消费消息会有延迟，消息消费时间不稳定。 </p></blockquote><h4 id="2-时间轮"><a href="#2-时间轮" class="headerlink" title="2.时间轮"></a>2.时间轮</h4><blockquote><p>实现：</p></blockquote><h3 id="数据一致性，幂等"><a href="#数据一致性，幂等" class="headerlink" title="数据一致性，幂等"></a>数据一致性，幂等</h3><h3 id="kafka为什么不适合做业务"><a href="#kafka为什么不适合做业务" class="headerlink" title="kafka为什么不适合做业务"></a>kafka为什么不适合做业务</h3><p>kafka缺少比如认证，SSL端等易于操作的工具等等功能。</p><h3 id="kafka为什么读写快"><a href="#kafka为什么读写快" class="headerlink" title="kafka为什么读写快"></a>kafka为什么读写快</h3><p>1.磁盘读写原理</p><p>2.利用Pagecache+mmap</p><p>3.零拷贝</p><p>4.存储设计</p><p>5.批量读写</p><p>6.批量压缩</p><p>7.消息写入过程</p><p>8.消息读取过程</p><hr><div align="center"><font color = orange>你的支持是我加班的动力</font><br/><strong>微信</strong><br/><img src="https://yycreate.github.io/img/wxzf.jpg" style="width:256px;"/><strong>支付宝</strong><br/><img src="https://yycreate.github.io/img/zfbzf_1.jpg" style="width:256px;"/></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>rabbit架构</title>
      <link href="/mq-rabbitmq/"/>
      <url>/mq-rabbitmq/</url>
      
        <content type="html"><![CDATA[<h3 id="单机架构"><a href="#单机架构" class="headerlink" title="单机架构"></a>单机架构</h3><p><img src="https://yycreate.github.io/img/image/mq/rabbit_mq_single.png" alt="rabbit_mq_single.png"></p><p>主要包含角色:</p><ul><li>producer: 生产者</li><li>comsumer: 消费者</li><li>msg: 消息</li><li>exchange： 交换机可以理解为路由规则 有dierct，fanout，topic，headers</li><li>queue: 队列，存储消息</li><li>channel： 虚拟通道，发送/接收消息都是通过这</li><li>connection： 与mq的tcp链接</li><li>Broker:简单来说，就是一个消息队列服务器实体。</li></ul><h3 id="多机架构"><a href="#多机架构" class="headerlink" title="多机架构"></a>多机架构</h3><p>broker是一个集群概念，集群内可能会有很多消息服务器群体，但先不看那么大的架构。仅看一个broker内：</p><p>broker内可以部署多个虚拟主机，逻辑架构，从而提高整个集群消息消费速度<br><img src="https://yycreate.github.io/img/image/mq/rabbit_mq_more.png" alt="rabbit_mq_more.png"></p><h3 id="延时队列实现逻辑"><a href="#延时队列实现逻辑" class="headerlink" title="延时队列实现逻辑"></a>延时队列实现逻辑</h3><p>延时队列实现逻辑，通过TTL（time to live）消息生存事件记录；当消息过期了会进入死信交换机（DLX）到正常队列进行消费，达到延时消息消费。<br><img src="https://yycreate.github.io/img/image/mq/dead_line_queue.png" alt="dead_line_queue.png"></p><h3 id="ttl机制"><a href="#ttl机制" class="headerlink" title="ttl机制"></a>ttl机制</h3><p><img src="https://yycreate.github.io/img/image/mq/ttl.png" alt="ttl.png"></p><h3 id="rabbit-集群部署"><a href="#rabbit-集群部署" class="headerlink" title="rabbit 集群部署"></a>rabbit 集群部署</h3><p>ttl机制分为两种：</p><ul><li>消息TTL</li><li>队列TTL</li></ul><hr><div align="center"><font color = orange>你的支持是我加班的动力</font><br/><strong>微信</strong><br/><img src="https://yycreate.github.io/img/wxzf.jpg" style="width:256px;"/><strong>支付宝</strong><br/><img src="https://yycreate.github.io/img/zfbzf_1.jpg" style="width:256px;"/></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>elasticsearch实际应用场景与扩展方案，容灾方案</title>
      <link href="/es-es-work-place/"/>
      <url>/es-es-work-place/</url>
      
        <content type="html"><![CDATA[<p>浅显概括一下es的能力：分词能力，倒排索引，聚合计算能力。</p><p>能力示意图</p><h3 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h3><p>稍微了解一下elasticsearch生态</p><p><img src="https://yycreate.github.io/img/es/es_env.png" alt="es_env.png"></p><h4 id="1-实时日志分析"><a href="#1-实时日志分析" class="headerlink" title="1.实时日志分析"></a>1.实时日志分析</h4><p>主要运用场景：用户行为的业务日志（埋点），运营日志（系统的慢性能的接口）等等</p><blockquote><p>通常这种场景使用elk/efk完成：<br><img src="https://yycreate.github.io/img/es/EFK.png" alt="EFK.png"></p></blockquote><p>扩容：</p><h4 id="2-搜索服务"><a href="#2-搜索服务" class="headerlink" title="2.搜索服务"></a>2.搜索服务</h4><blockquote><p>微服务小程序内容索引架构，可以基于不同业务将数据拆分为多个子库做业务隔离。<br><img src="https://yycreate.github.io/img/es/es_search.png" alt="es_search.png"></p><p>适用业务<br>例如：feed流</p></blockquote><h4 id="3-时序分析"><a href="#3-时序分析" class="headerlink" title="3.时序分析"></a>3.时序分析</h4><p>TimeStream优化Elasticsearch在存储指标数据方面的DSL查询复杂且慢以及存储成本过高等问题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUT _time_stream/test_stream</span><br></pre></td></tr></table></figure><blockquote><p>TimeStream+Es+Prometheus+Grafana<br><img src="https://yycreate.github.io/img/es/Grafana.png" alt="Grafana.png"></p></blockquote><h3 id="es集群优化方案"><a href="#es集群优化方案" class="headerlink" title="es集群优化方案"></a>es集群优化方案</h3><h4 id="1-主要的优化项"><a href="#1-主要的优化项" class="headerlink" title="1.主要的优化项"></a>1.主要的优化项</h4><p><img src="https://yycreate.github.io/img/es/es_well_direction.png" alt="img_1.png"></p><h5 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a><font color=#329999>优化方案</font></h5><p>限流方案：</p><ul><li>内部服务调用权限，只有认证的服务才能进行调度。</li><li>使用队列：优化队列优先级</li><li>内存优化使用：全链路 + 精准匹配</li><li>多租户: CVM/Cgroups</li></ul><p>成本优化方案：</p><p>硬件成本</p><ul><li>冷热分离：使用混合存储平衡成本，性能</li><li>Rollup：预计算换取存储，性能</li><li>备份归档：使用廉价的存储系统备份</li><li>存储裁剪，生命周期管理等等</li></ul><p>内存成本</p><ul><li>LRU Cache：提升内存利用率 </li><li>Off Heap：降低堆内存，提高节点规格</li></ul><h5 id="方案实践"><a href="#方案实践" class="headerlink" title="方案实践"></a><font color=#329999>方案实践</font></h5><p>es6.x开始推出Rollup。</p><blockquote><p>Rollup 类似于大数据场景下的 Cube、物化视图，它的核心思想是通过预计算提前生成统计信息，释放掉原始粒度数据，从而降低存储成本、提高查询性能，通常会有数据级的收益。</p></blockquote><p>// TODO</p><p>索引汇总作业<br><a href="https://www.modb.pro/db/444747" target="_blank" rel="noopener">https://www.modb.pro/db/444747</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>pod 配置demo</title>
      <link href="/k8s-pod-setting/"/>
      <url>/k8s-pod-setting/</url>
      
        <content type="html"><![CDATA[<p><a href="https://kubernetes.io/zh-cn/docs/tasks/debug/debug-cluster/resource-metrics-pipeline/" target="_blank" rel="noopener">https://kubernetes.io/zh-cn/docs/tasks/debug/debug-cluster/resource-metrics-pipeline/</a></p><h3 id="安装简化的k8s集群-kuboard-spray"><a href="#安装简化的k8s集群-kuboard-spray" class="headerlink" title="安装简化的k8s集群 kuboard-spray"></a>安装简化的k8s集群 kuboard-spray</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --privileged \</span><br><span class="line">  --restart=unless-stopped \</span><br><span class="line">  --name=kuboard-spray \</span><br><span class="line">  -p 80:80/tcp \</span><br><span class="line">  -v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">  -v ~/kuboard-spray-data:/data \</span><br><span class="line">  eipwork/kuboard-spray:latest-amd64</span><br></pre></td></tr></table></figure><p>docker run -d —privileged —restart=unless-stopped —name=kuboard-spray -p 80:80/tcp -v /var/run/docker.sock:/var/run/docker.sock -v ~/kuboard-spray-data:D\:/data eipwork/kuboard-spray:latest-amd64</p><h3 id="轻量版k8s-k3s"><a href="#轻量版k8s-k3s" class="headerlink" title="轻量版k8s - k3s"></a>轻量版k8s - k3s</h3><p><a href="https://docs.k3s.io/zh/" target="_blank" rel="noopener">https://docs.k3s.io/zh/</a></p><blockquote><p>在浏览器打开地址 <a href="http://这台机器的IP，输入用户名" target="_blank" rel="noopener">http://这台机器的IP，输入用户名</a> admin，默认密码 Kuboard123，即可登录 Kuboard-Spray 界面</p></blockquote><hr><h3 id="为POD分配资源"><a href="#为POD分配资源" class="headerlink" title="为POD分配资源"></a>为POD分配资源</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">memory-demo</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">mem-example</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">memory-demo-ctr</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">polinux/stress</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">requests:</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">"100Mi"</span></span><br><span class="line">      <span class="attr">limits:</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">"200Mi"</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">["stress"]</span></span><br><span class="line">    <span class="attr">args:</span> <span class="string">["--vm",</span> <span class="string">"1"</span><span class="string">,</span> <span class="string">"--vm-bytes"</span><span class="string">,</span> <span class="string">"150M"</span><span class="string">,</span> <span class="string">"--vm-hang"</span><span class="string">,</span> <span class="string">"1"</span><span class="string">]</span></span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title="#"></a>#</h2><hr><h3 id="k8s工具-管理工具"><a href="#k8s工具-管理工具" class="headerlink" title="k8s工具 管理工具"></a>k8s工具 管理工具</h3><h4 id="kubeshpere"><a href="#kubeshpere" class="headerlink" title="kubeshpere"></a>kubeshpere</h4><h4 id="kuboard"><a href="#kuboard" class="headerlink" title="kuboard"></a>kuboard</h4><p><a href="https://kuboard.cn/learning/" target="_blank" rel="noopener">https://kuboard.cn/learning/</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>容灾</title>
      <link href="/error-error/"/>
      <url>/error-error/</url>
      
        <content type="html"><![CDATA[<h2 id="容灾策略"><a href="#容灾策略" class="headerlink" title="容灾策略"></a>容灾策略</h2><h3 id="服务容灾保障"><a href="#服务容灾保障" class="headerlink" title="服务容灾保障"></a>服务容灾保障</h3><ul><li>限流</li><li>切换</li><li>关闭有损服务/服务降级-旁路</li></ul><h3 id="数据集容灾保障"><a href="#数据集容灾保障" class="headerlink" title="数据集容灾保障"></a>数据集容灾保障</h3><ul><li>数据库跨机房，跨层容灾 - 自制兼容mysql协议兼容方案</li><li>开源方案</li><li>传统银行</li></ul><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><blockquote><p>manager meta master-and-slave</p><p>manager多-&gt;zookeeper选主-&gt;MGR跨机房容灾</p><p>切换机制可靠性</p><p>网关（用于鉴权）</p></blockquote><p> 数据库备份</p><ul><li>3个副本，挂了，一个还需要备份</li><li>断网络</li><li>备份数据最多节点</li><li>数据校准</li></ul><p>故障</p><ul><li>灰度故障 -&gt; MGR多套</li><li>半网故障</li></ul><h3 id="设计层面"><a href="#设计层面" class="headerlink" title="设计层面"></a>设计层面</h3><p>监控状态：</p><ol><li>配置类</li><li>状态类</li><li>底层依赖</li></ol><p>子机事物集合是主机所有的事物。切换机器时，检查gtid，需常态检查，防止平时操作产生gtid。<br>agent 探测数据库状态，死，活，半活，分布式探测服务。   </p><p>备份</p><ol><li>增量备份（实时）</li><li>延迟备机（一天）</li><li>全量备份（一周，离线数据）</li></ol><p>？怎么确认备份数据是正确的</p><ol><li>备份 -&gt; 恢复到线上的，数据追平 -&gt; 数据正确</li><li>modify_time </li><li></li></ol><h3 id="容灾压测"><a href="#容灾压测" class="headerlink" title="容灾压测"></a>容灾压测</h3><p>网络断容演练</p><ul><li>网络全断</li><li>网络50%断</li><li>部分网段断</li><li>抖动性断</li></ul><hr><div align="center"><font color = orange>你的支持是我加班的动力</font><br/><strong>微信</strong><br/><img src="https://yycreate.github.io/img/wxzf.jpg" style="width:256px;"/><strong>支付宝</strong><br/><img src="https://yycreate.github.io/img/zfbzf_1.jpg" style="width:256px;"/></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>es部署方式</title>
      <link href="/es-es-set/"/>
      <url>/es-es-set/</url>
      
        <content type="html"><![CDATA[<h3 id="1-集群-cluster"><a href="#1-集群-cluster" class="headerlink" title="1.集群 cluster"></a>1.集群 cluster</h3><blockquote><p>集群部署拓扑图<br><img src="https://yycreate.github.io/img/es/cluster_build.png" alt="img.png"><br>副分片的数量可以设置的，一个Primary shard可以对应多个Replica shard</p><p>将所有数据主分片分到多个节点node中，将副分片保存在不同的节点中 （主要避免某个节点不可用时，其他节点可以提供数据使用或恢复）</p></blockquote><h4 id="集群状态颜色"><a href="#集群状态颜色" class="headerlink" title="集群状态颜色"></a><font color=#329999>集群状态颜色</font></h4><ul><li>绿色</li><li>黄色</li><li>红色</li></ul><h4 id="单点故障转移"><a href="#单点故障转移" class="headerlink" title="单点故障转移"></a><font color=#329999>单点故障转移</font></h4><p>当只有一个节点的时候，副本RS是不会生效的，表示节点宕机时候，数据还是不可用，不会冗余数据。容错率是0%。</p><p>当只有两个节点时，数据会会有主分片和副分片，每个node上都有完整的数据。容错率是50%。</p><p>当有多个节点时候，为了分散负载堆分片重新分配。（CPU,RAM,I/O）等资源被更少数据共享。</p><h4 id="集群故障转移"><a href="#集群故障转移" class="headerlink" title="集群故障转移"></a><font color=#329999>集群故障转移</font></h4><blockquote><p>集群故障转移<br><img src="https://yycreate.github.io/img/es/cluster_error.png" alt="cluster_error.png"></p><p>集群中一个节点故障，故障节点<code>primary shard</code>的副本<code>Replica shard</code>会主动升级为<code>primary shard</code>继续提供服务。</p><p>然而如图所示，只剩下6 of 9节点使用，集群状态为yellow。</p></blockquote><h4 id="路由计算-amp-分片控制"><a href="#路由计算-amp-分片控制" class="headerlink" title="路由计算 &amp; 分片控制"></a><font color=#329999>路由计算 &amp; 分片控制</font></h4><blockquote><p>分片逻辑: SHARD = HASH(routing)%number_of_primary_shards</p></blockquote><h4 id="数据写流程"><a href="#数据写流程" class="headerlink" title="数据写流程"></a><font color=#329999>数据写流程</font></h4><p>请求会走到协调节点，协调节点可以是集群中任意节点。</p><blockquote><p>客户端写请求<br><img src="https://yycreate.github.io/img/es/es_write.png" alt="img_1.png"></p><p>1.客户端协写请求（协调节点）</p><p>2.协调节点到指定分片节点</p><p>3.主节点保存数据</p><p>4.主节点发送数据到副本（可以设置副本同步时间）</p><p>5.副本保存后反馈</p><p>6.主分片反馈</p><p>7.客户端收到，写请求完成</p></blockquote><h4 id="数据读流程"><a href="#数据读流程" class="headerlink" title="数据读流程"></a><font color=#329999>数据读流程</font></h4><p>协调节点是任意的，节点分为数据节点，协调节点，master节点</p><blockquote><p>客户端读操作<br><img src="https://yycreate.github.io/img/es/es_read.png" alt="img.png"></p><p>1.协调节点获取请求</p><p>2.计算DSL语句，找到主分片，副分片所在的节点</p><p>3.根据轮询策略，请求转发到其他节点上</p><p>4.协调节点获取到查询文档后，返回给客户端</p></blockquote><h4 id="数据更新流程"><a href="#数据更新流程" class="headerlink" title="数据更新流程"></a><font color=#329999>数据更新流程</font></h4><blockquote><p>更新数据<br><img src="https://yycreate.github.io/img/es/es_update.png" alt="img.png"></p><p>1.客户端调用协调节点</p><p>2.协调节点找到数据主分片，同步数据和索引</p><p>3.从主分片读取_source，若主分片被其他进程占用，会重试至放弃。</p><p>4.主分片同步完，给所有副分片发送文档同步和索引同步</p><p>5.所有副分片返回成功，主分片返回成功给协调节点，最终返回给客户端</p></blockquote><h4 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a><font color=#329999>倒排索引</font></h4><blockquote><p>Elasticsearch使用倒排索引的结构，它适用于快速的全文搜索。</p></blockquote><h5 id="正向索引"><a href="#正向索引" class="headerlink" title="正向索引"></a>正向索引</h5><p>先介绍什么是正向索引</p><blockquote><p>搜索引擎会把文档对应文件的一个ID，根据ID搜索到对应的文档和字段。<br><img src="https://yycreate.github.io/img/es/index_front.png" alt="img_1.png"></p></blockquote><h5 id="倒排索引-1"><a href="#倒排索引-1" class="headerlink" title="倒排索引"></a>倒排索引</h5><p>倒排索引就是根据对应的关键字，找到对应的文档</p><blockquote><p>建立关键字与所有关联的文档内容，id等等信息<br><img src="https://yycreate.github.io/img/es/index_back.png" alt="img.png"></p><p>难点：todo</p></blockquote><hr><div align="center"><font color = orange>你的支持是我加班的动力</font><br/><strong>微信</strong><br/><img src="https://yycreate.github.io/img/wxzf.jpg" style="width:256px;"/><strong>支付宝</strong><br/><img src="https://yycreate.github.io/img/zfbzf_1.jpg" style="width:256px;"/></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo blog</title>
      <link href="/blog/"/>
      <url>/blog/</url>
      
        <content type="html"><![CDATA[<p>start server<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure></p><p>deploy<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure></p><p>change theme<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cd blog</span><br><span class="line">rm -rf source</span><br><span class="line">rm -rf scaffolds</span><br><span class="line">rm _config.yml package.json README.md LICENSE</span><br><span class="line">git clone https://github.com/dusign/hexo-theme-snail.git</span><br><span class="line">mv ./hexo-theme-snail/snail ./themes</span><br><span class="line">mv ./hexo-theme-snail/* ./</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-Theme-Snail</title>
      <link href="/2019-11-01-Hexo-Theme-Snail/"/>
      <url>/2019-11-01-Hexo-Theme-Snail/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo-theme-snail"><a href="#hexo-theme-snail" class="headerlink" title="hexo-theme-snail"></a>hexo-theme-snail</h1><p><a href="https://github.com/dusign/hexo-theme-snail" target="_blank" rel="noopener">View Hexo-Theme-Snail Sources On Github &#10174; </a></p><p><a href="https://www.dusign.net" target="_blank" rel="noopener">View Live Super Snail Blog &#10174;</a></p><p><img src="snail.png" alt="hexo-theme-snail"></p><p>Hexo-theme-snail is a succinct hexo theme. It has two colors, light and star, that can be set according to your own preferences in the settings, and also has the functions of sharing and commenting. More features are under development.</p><h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h2><ul><li>light color theme and star theme</li><li>diversified comment system</li><li>notice tips</li><li>share to other platforms (under development)</li><li>picture sharing (under development)</li></ul><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Install-Hexo"><a href="#Install-Hexo" class="headerlink" title="Install Hexo"></a>Install Hexo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-cli -g</span><br></pre></td></tr></table></figure><h3 id="Setup-your-blog"><a href="#Setup-your-blog" class="headerlink" title="Setup your blog"></a>Setup your blog</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init blog</span><br></pre></td></tr></table></figure><h3 id="Installation-Theme"><a href="#Installation-Theme" class="headerlink" title="Installation Theme"></a>Installation Theme</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line">$ rm -rf <span class="built_in">source</span></span><br><span class="line">$ rm _config.yml package.json README.md LICENSE</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/dusign/hexo-theme-snail.git</span><br><span class="line">$ mv ./hexo-theme-snail/snail ./themes</span><br><span class="line">$ mv ./hexo-theme-snail/* ./</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><h3 id="Set-Theme"><a href="#Set-Theme" class="headerlink" title="Set Theme"></a>Set Theme</h3><p>Modify the value of <code>theme:</code> in <code>_config.yml</code><br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">snail</span></span><br></pre></td></tr></table></figure></p><h3 id="Start-the-Server"><a href="#Start-the-Server" class="headerlink" title="Start the Server"></a>Start the Server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><h2 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h2><h3 id="Site"><a href="#Site" class="headerlink" title="Site"></a>Site</h3><p>Replace the following information with your own.<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> </span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">At</span> <span class="string">the</span> <span class="string">bottom</span> <span class="string">of</span> <span class="string">the</span> <span class="string">well,</span> <span class="string">it</span> <span class="string">is</span> <span class="string">destined</span> <span class="string">to</span> <span class="string">see</span> <span class="string">only</span> <span class="string">the</span> <span class="string">sky</span> <span class="string">at</span> <span class="string">the</span> <span class="string">wellhead.</span> </span><br><span class="line">          <span class="string">However,</span> <span class="string">the</span> <span class="string">starting</span> <span class="string">point</span> <span class="string">only</span> <span class="string">affects</span> <span class="string">the</span> <span class="string">process</span> <span class="string">of</span> <span class="string">reaching</span> <span class="string">your</span> <span class="string">peak</span> <span class="string">and</span> <span class="string">does</span> <span class="string">not</span> <span class="string">determine</span> <span class="string">the</span> <span class="string">height</span> <span class="string">you</span> <span class="string">reach.</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Dusign</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">en</span></span><br><span class="line"><span class="attr">timezone:</span></span><br></pre></td></tr></table></figure></p><h3 id="Site-Settings"><a href="#Site-Settings" class="headerlink" title="Site Settings"></a>Site Settings</h3><p>Put customized pictures in <code>img</code> directory.<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site settings</span></span><br><span class="line"><span class="attr">SEOTitle:</span> <span class="string">Hexo-theme-snail</span></span><br><span class="line"><span class="attr">email:</span> <span class="string">hexo-theme-snail@mail.com</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">"A hexo theme"</span></span><br><span class="line"><span class="attr">keyword:</span> <span class="string">"dusign, hexo-theme-snail"</span></span><br><span class="line"><span class="attr">header-img:</span> <span class="string">img/header_img/home-bg-1-dark.jpg</span></span><br><span class="line"><span class="attr">signature:</span> <span class="literal">true</span> <span class="comment">#show signature</span></span><br><span class="line"><span class="attr">signature-img:</span> <span class="string">img/signature/Just-do-it-white.png</span></span><br></pre></td></tr></table></figure></p><h3 id="SNS-Settings"><a href="#SNS-Settings" class="headerlink" title="SNS Settings"></a>SNS Settings</h3><p>If you don’t want to display it, you can delete it directly.<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SNS settings</span></span><br><span class="line"><span class="attr">github_username:</span>    <span class="string">dusign</span></span><br><span class="line"><span class="attr">twitter_username:</span>   <span class="string">dusignr</span></span><br><span class="line"><span class="attr">facebook_username:</span>  <span class="string">Gang</span> <span class="string">Du</span></span><br><span class="line"><span class="attr">zhihu_username:</span> <span class="string">dusignr</span></span><br></pre></td></tr></table></figure></p><h3 id="Sidebar-Settings"><a href="#Sidebar-Settings" class="headerlink" title="Sidebar Settings"></a>Sidebar Settings</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Sidebar Settings</span></span><br><span class="line"><span class="attr">sidebar:</span> <span class="literal">true</span>                      <span class="comment"># whether or not using Sidebar.</span></span><br><span class="line"><span class="attr">sidebar-about-description:</span> <span class="string">"Welcome to visit, I'm Dusign!"</span></span><br><span class="line"><span class="attr">sidebar-avatar:</span> <span class="string">img/ironman-draw.png</span>      <span class="comment"># use absolute URL, seeing it's used in both `/` and `/about/`</span></span><br><span class="line"><span class="attr">widgets:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">featured-tags</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">short-about</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">recent-posts</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">friends-blog</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">archive</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">category</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># widget behavior</span></span><br><span class="line"><span class="comment">## Archive</span></span><br><span class="line"><span class="attr">archive_type:</span> <span class="string">'monthly'</span></span><br><span class="line"><span class="attr">show_count:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## Featured Tags</span></span><br><span class="line"><span class="attr">featured-tags:</span> <span class="literal">true</span>                     <span class="comment"># whether or not using Feature-Tags</span></span><br><span class="line"><span class="attr">featured-condition-size:</span> <span class="number">1</span>              <span class="comment"># A tag will be featured if the size of it is more than this condition value</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## Friends</span></span><br><span class="line"><span class="attr">friends:</span> <span class="string">[</span></span><br><span class="line">    <span class="string">&#123;</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">"Dusign's Blog"</span><span class="string">,</span></span><br><span class="line">        <span class="attr">href:</span> <span class="string">"https://blog.csdn.net/d_Nail"</span></span><br><span class="line">    <span class="string">&#125;,&#123;</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">"Dusign's Web"</span><span class="string">,</span></span><br><span class="line">        <span class="attr">href:</span> <span class="string">"#"</span></span><br><span class="line">    <span class="string">&#125;,&#123;</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">"Dusign's Github"</span><span class="string">,</span></span><br><span class="line">        <span class="attr">href:</span> <span class="string">"https://github.com/dusign"</span></span><br><span class="line">    <span class="string">&#125;,&#123;</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">"Other"</span><span class="string">,</span></span><br><span class="line">        <span class="attr">href:</span> <span class="string">"#"</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line"><span class="string">]</span></span><br></pre></td></tr></table></figure><h3 id="Theme"><a href="#Theme" class="headerlink" title="Theme"></a>Theme</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">snail</span></span><br></pre></td></tr></table></figure><h3 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span></span><br><span class="line">      <span class="attr">github:</span> <span class="string">github.repository.address</span></span><br><span class="line">      <span class="attr">coding:</span> <span class="string">coding.repository.address</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><h3 id="Comment"><a href="#Comment" class="headerlink" title="Comment"></a>Comment</h3><p>See httpymls://github.com/imsun/gitment for detailed configuration method.<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Comment</span></span><br><span class="line"><span class="comment">## This comment system is gitment</span></span><br><span class="line"><span class="comment">## gitment url: https://github.com/imsun/gitment</span></span><br><span class="line"><span class="attr">comment:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">owner:</span></span><br><span class="line">  <span class="attr">repo:</span></span><br><span class="line">  <span class="attr">client_id:</span></span><br><span class="line">  <span class="attr">client_secret:</span></span><br></pre></td></tr></table></figure></p><h3 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Tip</span></span><br><span class="line"><span class="attr">tip:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">content:</span> <span class="string">欢迎访问</span> <span class="string">&lt;a</span> <span class="string">href="https://www.dusign.net"</span> <span class="string">target="dusign"&gt;dusign&lt;/a&gt;</span> <span class="string">的博客，博客系统一键分享的功能还在完善中，请大家耐心等待。</span></span><br><span class="line">          <span class="string">若有问题或者有好的建议欢迎留言，笔者看到之后会及时回复。</span></span><br><span class="line">          <span class="string">评论点赞需要github账号登录，如果没有账号的话请点击</span> </span><br><span class="line">          <span class="string">&lt;a</span> <span class="string">href="https://github.com"</span> <span class="string">target="view_window"</span> <span class="string">&gt;</span> <span class="string">github</span> <span class="string">&lt;/a&gt;</span> <span class="string">注册，</span> <span class="string">谢谢</span> <span class="string">!</span></span><br></pre></td></tr></table></figure><h3 id="Color-Sheme"><a href="#Color-Sheme" class="headerlink" title="Color Sheme"></a>Color Sheme</h3><p>Set the <code>enable</code> value of the desired color sheme to <code>true</code>. If the value of <code>bg_effects.star.enable</code> is <code>true</code>, please modify the value of <code>highlight_theme</code> in <code>./themes/snail/_config.yml</code> to <code>night</code>.<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Color Sheme</span></span><br><span class="line"><span class="comment">## If there is no effect after modification, please empty the cache and try again.</span></span><br><span class="line"><span class="comment">## ⚠️ The following special effects will take up a lot of cpu resorces, please open it carefully.</span></span><br><span class="line"><span class="attr">bg_effects:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">color:</span> <span class="number">129</span><span class="string">,200,61</span></span><br><span class="line">    <span class="attr">pointColor:</span> <span class="number">129</span><span class="string">,200,61</span></span><br><span class="line">    <span class="attr">opacity:</span> <span class="number">0.7</span></span><br><span class="line">    <span class="attr">zIndex:</span> <span class="number">-9</span></span><br><span class="line">    <span class="attr">count:</span> <span class="number">99</span></span><br><span class="line">  <span class="attr">mouse_click:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">content:</span> <span class="string">'"🌱","just do it","🌾","🍀","don'</span><span class="string">'t give up","🍂","🌻","try it again","🍃","never say die","🌵","🌿","🌴"'</span></span><br><span class="line">    <span class="attr">color:</span> <span class="string">'"rgb(121,93,179)"</span></span><br><span class="line"><span class="string">          ,"rgb(76,180,231)"</span></span><br><span class="line"><span class="string">          ,"rgb(184,90,154)"</span></span><br><span class="line"><span class="string">          ,"rgb(157,211,250)"</span></span><br><span class="line"><span class="string">          ,"rgb(255,0,0)"</span></span><br><span class="line"><span class="string">          ,"rgb(242,153,29)"</span></span><br><span class="line"><span class="string">          ,"rgb(23,204,16)"</span></span><br><span class="line"><span class="string">          ,"rgb(222,0,0)"</span></span><br><span class="line"><span class="string">          ,"rgb(22,36,92)"</span></span><br><span class="line"><span class="string">          ,"rgb(127,24,116)"</span></span><br><span class="line"><span class="string">          ,"rgb(119,195,79)"</span></span><br><span class="line"><span class="string">          ,"rgb(4,77,34)"</span></span><br><span class="line"><span class="string">          ,"rgb(122,2,60)"'</span></span><br><span class="line">  <span class="attr">star:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><h2 id="Releases"><a href="#Releases" class="headerlink" title="Releases"></a>Releases</h2><p>V1.0</p><ul><li>fix the bugs</li><li>add comment system</li><li>add notice tips</li><li>add star sheme</li></ul><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>Apache License 2.0 Copyright(c) 2018-2020 <a href="https://github.com/dusign" target="_blank" rel="noopener">Dusign</a>   </p><p><a href="https://github.com/dusign/hexo-theme-snail" target="_blank" rel="noopener">hexo-theme-snail</a> is derived from <a href="https://github.com/Huxpro/huxpro.github.io" target="_blank" rel="noopener">Huxpro</a> Apache License 2.0. Copyright (c) 2015-2020 Huxpro</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo-theme-snail </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
